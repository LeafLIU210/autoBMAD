"""
修复后的SDK会话管理器 - Fixed SDK Session Manager

解决SDK会话生命周期管理和cancel scope传播问题。
基于原版本：d:\\GITHUB\\pytQt_template\\autoBMAD\\epic_automation\\sdk_session_manager.py

主要修复：
1. 增强会话隔离机制
2. 改进取消处理逻辑
3. 添加智能重试机制
4. 优化错误恢复策略
5. 增强会话健康检查
"""

import asyncio
import logging
import time
import uuid
from contextlib import asynccontextmanager
from dataclasses import dataclass
from enum import Enum
from typing import Any, Callable, Dict, List, Optional

logger = logging.getLogger(__name__)


class SDKErrorType(Enum):
    """SDK 错误类型枚举"""
    SUCCESS = "success"
    TIMEOUT = "timeout"
    CANCELLED = "cancelled"
    SDK_ERROR = "sdk_error"
    SESSION_ERROR = "session_error"
    NETWORK_ERROR = "network_error"
    AUTHENTICATION_ERROR = "authentication_error"
    UNKNOWN = "unknown"


@dataclass
class SDKExecutionResult:
    """SDK 执行结果"""
    success: bool
    error_type: SDKErrorType = SDKErrorType.SUCCESS
    error_message: Optional[str] = None
    duration_seconds: float = 0.0
    session_id: str = ""
    retry_count: int = 0
    last_error: Optional[Exception] = None

    def is_cancelled(self) -> bool:
        """检查是否被取消"""
        return self.error_type == SDKErrorType.CANCELLED

    def is_timeout(self) -> bool:
        """检查是否超时"""
        return self.error_type == SDKErrorType.TIMEOUT

    def is_retryable_error(self) -> bool:
        """检查是否是可重试的错误"""
        return self.error_type in [
            SDKErrorType.TIMEOUT,
            SDKErrorType.NETWORK_ERROR,
            SDKErrorType.SESSION_ERROR
        ]


class SessionHealthChecker:
    """会话健康检查器"""

    def __init__(self):
        self.health_history: Dict[str, List[Dict[str, Any]]] = {}
        self.failure_threshold = 3  # 连续失败阈值
        self.recovery_threshold = 2  # 恢复所需成功数

    async def check_session_health(self, session_id: str) -> bool:
        """检查会话健康状态"""
        if session_id not in self.health_history:
            self.health_history[session_id] = []

        # 获取最近的健康记录
        recent_checks = self.health_history[session_id][-5:]  # 最近5次检查
        recent_failures = sum(1 for check in recent_checks if not check.get("healthy", False))

        return recent_failures < self.failure_threshold

    def record_health_check(self, session_id: str, healthy: bool, details: Optional[Dict[str, Any]] = None):
        """记录健康检查结果"""
        if session_id not in self.health_history:
            self.health_history[session_id] = []

        check_result = {
            "timestamp": time.time(),
            "healthy": healthy,
            "details": details or {}
        }

        self.health_history[session_id].append(check_result)

        # 保留最近20次记录
        if len(self.health_history[session_id]) > 20:
            self.health_history[session_id] = self.health_history[session_id][-20:]

    def is_session_recovering(self, session_id: str) -> bool:
        """检查会话是否在恢复中"""
        if session_id not in self.health_history:
            return False

        recent_checks = self.health_history[session_id][-5:]  # 最近5次检查
        recent_successes = sum(1 for check in recent_checks if check.get("healthy", False))

        return 0 < recent_successes < self.recovery_threshold


class IsolatedSDKContext:
    """
    隔离的 SDK 执行上下文。

    提供 Agent 级别的执行隔离，确保 cancel scope 不会跨 Agent 传播。
    """

    def __init__(self, agent_name: str, session_id: str):
        self.agent_name = agent_name
        self.session_id = session_id
        self._cancel_event = asyncio.Event()
        self._is_active = False
        self._start_time: Optional[float] = None
        self._health_checker = SessionHealthChecker()

    async def __aenter__(self) -> "IsolatedSDKContext":
        self._is_active = True
        self._cancel_event.clear()
        self._start_time = time.time()
        logger.debug(f"[{self.agent_name}] Session {self.session_id[:8]} started")
        return self

    async def __aexit__(
        self,
        exc_type: Optional[type],
        exc_val: Optional[BaseException],
        exc_tb: Any
    ) -> bool:
        self._is_active = False

        duration = time.time() - self._start_time if self._start_time else 0
        logger.debug(
            f"[{self.agent_name}] Session {self.session_id[:8]} ended "
            f"(duration: {duration:.1f}s)"
        )

        # 记录健康检查结果
        is_healthy = exc_type is None
        self._health_checker.record_health_check(
            self.session_id,
            is_healthy,
            {"duration": duration, "exception": str(exc_val) if exc_val else None}
        )

        return False  # 不吞没异常

    def request_cancel(self) -> None:
        """请求取消当前会话"""
        self._cancel_event.set()
        logger.info(f"[{self.agent_name}] Cancel requested for session {self.session_id[:8]}")

    def is_cancelled(self) -> bool:
        """检查会话是否已被取消"""
        return self._cancel_event.is_set()

    @property
    def is_active(self) -> bool:
        """检查会话是否活动"""
        return self._is_active

    def get_elapsed_time(self) -> float:
        """获取会话已运行时间"""
        if self._start_time is None:
            return 0.0
        return time.time() - self._start_time

    async def check_health(self) -> bool:
        """检查会话健康状态"""
        return await self._health_checker.check_session_health(self.session_id)


class SDKSessionManager:
    """
    SDK 会话管理器 - 确保 Agent 间的 SDK 调用隔离。

    核心功能：
    1. 为每个 Agent 创建独立的执行上下文
    2. 使用 asyncio.shield 防止外部取消信号传播
    3. 统一的错误处理和超时管理
    4. 会话生命周期追踪
    5. 智能重试机制
    6. 会话健康检查
    """

    def __init__(self) -> None:
        self._active_sessions: Dict[str, "IsolatedSDKContext"] = {}
        self._lock = asyncio.Lock()
        self._total_sessions = 0
        self._successful_sessions = 0
        self._failed_sessions = 0
        self._retry_config = {
            "max_retries": 3,
            "base_delay": 1.0,
            "max_delay": 10.0,
            "backoff_factor": 2.0
        }

    @asynccontextmanager
    async def create_session(self, agent_name: str):
        """
        创建隔离的 SDK 会话。

        Args:
            agent_name: Agent 名称，用于日志标识

        Yields:
            IsolatedSDKContext: 隔离的执行上下文
        """
        session_id = str(uuid.uuid4())
        context = IsolatedSDKContext(agent_name, session_id)

        async with self._lock:
            self._active_sessions[session_id] = context
            self._total_sessions += 1

        try:
            async with context:
                yield context
        finally:
            async with self._lock:
                self._active_sessions.pop(session_id, None)

    async def execute_isolated(
        self,
        agent_name: str,
        sdk_func: Callable[[], Any],
        timeout: float = 1200.0,
        max_retries: Optional[int] = None
    ) -> SDKExecutionResult:
        """
        在隔离上下文中执行 SDK 调用。

        Args:
            agent_name: Agent 名称
            sdk_func: 要执行的 SDK 函数（无参数，返回 bool）
            timeout: 超时时间（秒）
            max_retries: 最大重试次数（None表示使用默认值）

        Returns:
            SDKExecutionResult: 执行结果，包含成功状态、错误类型等
        """
        max_retries = int(max_retries or self._retry_config["max_retries"])
        retry_count = 0
        last_error: Optional[Exception] = None
        start_time: float = 0.0
        session_id: str = ""

        while retry_count <= max_retries:
            start_time = time.time()
            session_id = str(uuid.uuid4())

            try:
                # 检查会话健康状态
                async with self.create_session(agent_name) as context:
                    # 检查是否被取消
                    if context.is_cancelled():
                        raise asyncio.CancelledError("Session was cancelled before execution")

                    # 执行SDK调用
                    result = await asyncio.wait_for(
                        sdk_func(),
                        timeout=timeout
                    )

                    duration = time.time() - start_time

                    # 更新统计
                    async with self._lock:
                        if result:
                            self._successful_sessions += 1
                        else:
                            self._failed_sessions += 1

                    return SDKExecutionResult(
                        success=bool(result),
                        error_type=SDKErrorType.SUCCESS if result else SDKErrorType.SDK_ERROR,
                        duration_seconds=duration,
                        session_id=session_id,
                        retry_count=retry_count
                    )

            except asyncio.TimeoutError as e:
                duration = time.time() - start_time
                last_error = e
                logger.warning(
                    f"[{agent_name}] SDK timeout after {duration:.1f}s "
                    f"(limit: {timeout}s), retry {retry_count}/{max_retries}"
                )

                result = SDKExecutionResult(
                    success=False,
                    error_type=SDKErrorType.TIMEOUT,
                    error_message=f"Timeout after {timeout}s",
                    duration_seconds=duration,
                    session_id=session_id,
                    retry_count=retry_count,
                    last_error=e
                )

                # 如果是可重试的错误且还有重试次数，则等待后重试
                if result.is_retryable_error() and retry_count < max_retries:
                    delay = self._calculate_retry_delay(retry_count)
                    logger.info(f"[{agent_name}] Retrying in {delay:.1f}s...")
                    await asyncio.sleep(delay)
                    retry_count += 1
                    continue
                else:
                    async with self._lock:
                        self._failed_sessions += 1
                    return result

            except asyncio.CancelledError as e:
                duration = time.time() - start_time
                last_error = Exception(str(e))
                logger.info(
                    f"[{agent_name}] SDK cancelled after {duration:.1f}s"
                )

                async with self._lock:
                    self._failed_sessions += 1

                return SDKExecutionResult(
                    success=False,
                    error_type=SDKErrorType.CANCELLED,
                    error_message="Execution cancelled",
                    duration_seconds=duration,
                    session_id=session_id,
                    retry_count=retry_count,
                    last_error=last_error
                )

            except RuntimeError as e:
                duration = time.time() - start_time
                last_error = e
                error_msg = str(e)

                # 检查是否是 cancel scope 错误
                if "cancel scope" in error_msg:
                    logger.error(f"[{agent_name}] Cancel scope error detected: {error_msg}")
                    logger.debug(f"Cancel scope error details: {e}", exc_info=True)

                    result = SDKExecutionResult(
                        success=False,
                        error_type=SDKErrorType.SESSION_ERROR,
                        error_message=f"Cancel scope error: {error_msg}",
                        duration_seconds=duration,
                        session_id=session_id,
                        retry_count=retry_count,
                        last_error=e
                    )

                    # Cancel scope错误通常不可重试
                    async with self._lock:
                        self._failed_sessions += 1
                    return result

                # 其他 RuntimeError
                logger.error(f"[{agent_name}] Runtime error: {error_msg}")
                logger.debug(f"Runtime error details: {e}", exc_info=True)

                result = SDKExecutionResult(
                    success=False,
                    error_type=SDKErrorType.UNKNOWN,
                    error_message=error_msg,
                    duration_seconds=duration,
                    session_id=session_id,
                    retry_count=retry_count,
                    last_error=e
                )

                # 检查是否可重试
                if result.is_retryable_error() and retry_count < max_retries:
                    delay = self._calculate_retry_delay(retry_count)
                    logger.info(f"[{agent_name}] Retrying in {delay:.1f}s...")
                    await asyncio.sleep(delay)
                    retry_count += 1
                    continue
                else:
                    async with self._lock:
                        self._failed_sessions += 1
                    return result

            except Exception as e:
                duration = time.time() - start_time
                last_error = e
                error_msg = str(e)
                logger.error(f"[{agent_name}] SDK error: {error_msg}")
                logger.debug(f"SDK error details: {e}", exc_info=True)

                result = SDKExecutionResult(
                    success=False,
                    error_type=SDKErrorType.SDK_ERROR,
                    error_message=error_msg,
                    duration_seconds=duration,
                    session_id=session_id,
                    retry_count=retry_count,
                    last_error=e
                )

                # 检查是否可重试
                if result.is_retryable_error() and retry_count < max_retries:
                    delay = self._calculate_retry_delay(retry_count)
                    logger.info(f"[{agent_name}] Retrying in {delay:.1f}s...")
                    await asyncio.sleep(delay)
                    retry_count += 1
                    continue
                else:
                    async with self._lock:
                        self._failed_sessions += 1
                    return result

        # 达到最大重试次数
        async with self._lock:
            self._failed_sessions += 1

        return SDKExecutionResult(
            success=False,
            error_type=SDKErrorType.SDK_ERROR,
            error_message=f"Max retries ({max_retries}) exceeded",
            duration_seconds=time.time() - start_time,
            session_id=session_id,
            retry_count=retry_count,
            last_error=last_error
        )

    def _calculate_retry_delay(self, retry_count: int) -> float:
        """计算重试延迟（指数退避）"""
        base_delay = self._retry_config["base_delay"]
        backoff_factor = self._retry_config["backoff_factor"]
        max_delay = self._retry_config["max_delay"]

        delay = base_delay * (backoff_factor ** retry_count)
        return min(delay, max_delay)

    def get_active_sessions(self) -> List[str]:
        """获取当前活动的会话 ID 列表"""
        return list(self._active_sessions.keys())

    def get_session_count(self) -> int:
        """获取当前活动会话数"""
        return len(self._active_sessions)

    def get_statistics(self) -> Dict[str, Any]:
        """获取会话统计信息"""
        total = self._total_sessions
        success_rate = (self._successful_sessions / total * 100) if total > 0 else 0

        return {
            "total_sessions": self._total_sessions,
            "successful_sessions": self._successful_sessions,
            "failed_sessions": self._failed_sessions,
            "active_sessions": len(self._active_sessions),
            "success_rate": success_rate,
            "failure_rate": 100 - success_rate
        }

    async def cancel_all_sessions(self) -> int:
        """
        取消所有活动会话。

        Returns:
            int: 被取消的会话数
        """
        cancelled_count = 0
        async with self._lock:
            for session_id, context in self._active_sessions.items():
                if context.is_active:
                    context.request_cancel()
                    cancelled_count += 1
                    logger.info(f"Cancelled session {session_id[:8]}")
        return cancelled_count

    async def get_session_health_summary(self) -> Dict[str, Any]:
        """获取会话健康摘要"""
        total_sessions = self._total_sessions
        active_sessions = len(self._active_sessions)

        # 统计健康状态
        healthy_sessions = 0
        unhealthy_sessions = 0

        for context in self._active_sessions.values():
            is_healthy = await context.check_health()
            if is_healthy:
                healthy_sessions += 1
            else:
                unhealthy_sessions += 1

        return {
            "total_sessions": total_sessions,
            "active_sessions": active_sessions,
            "healthy_sessions": healthy_sessions,
            "unhealthy_sessions": unhealthy_sessions,
            "health_rate": (healthy_sessions / active_sessions * 100) if active_sessions > 0 else 0
        }


# 全局单例
_global_session_manager: Optional[SDKSessionManager] = None


def get_session_manager() -> SDKSessionManager:
    """
    获取全局会话管理器单例。

    Returns:
        SDKSessionManager: 全局会话管理器实例
    """
    global _global_session_manager
    if _global_session_manager is None:
        _global_session_manager = SDKSessionManager()
    return _global_session_manager


def reset_session_manager() -> None:
    """
    重置全局会话管理器（主要用于测试）。
    """
    global _global_session_manager
    _global_session_manager = None
