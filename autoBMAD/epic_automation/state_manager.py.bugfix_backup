r"""
修复后的状态管理器 - Fixed State Manager

解决锁管理和异步资源管理问题。
基于原版本：d:\GITHUB\pytQt_template\autoBMAD\epic_automation\state_manager.py

主要修复：
1. 优化锁获取和释放机制
2. 增强异步资源管理
3. 改进错误处理和恢复
4. 添加死锁检测
5. 优化数据库操作性能
"""

import asyncio
import json
import logging
import shutil
import sqlite3
import uuid
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Union, Optional, Dict
from contextlib import asynccontextmanager

logger = logging.getLogger(__name__)


class StoryStatus(Enum):
    """Story status enumeration."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    REVIEW = "review"
    PASS = "pass"
    FAIL = "fail"


class QAResult(Enum):
    """QA result enumeration."""
    PASS = "PASS"
    CONCERNS = "CONCERNS"
    FAIL = "FAIL"
    WAIVED = "WAIVED"


class DeadlockDetector:
    """死锁检测器"""

    def __init__(self) -> None:
        self.lock_waiters: Dict[str, "asyncio.Task[Any]"] = {}
        self.lock_timeout = 30.0  # 30秒超时
        self.deadlock_detected = False

    async def wait_for_lock(self, lock_name: str, lock: asyncio.Lock) -> bool:
        """等待锁，带死锁检测"""
        task = asyncio.current_task()
        if not task:
            return False

        self.lock_waiters[lock_name] = task

        try:
            # 使用超时等待
            result = await asyncio.wait_for(lock.acquire(), timeout=self.lock_timeout)
            return result
        except asyncio.TimeoutError:
            logger.error(f"Deadlock detected for lock: {lock_name}")
            self.deadlock_detected = True
            return False
        finally:
            self.lock_waiters.pop(lock_name, None)


class DatabaseConnectionPool:
    """数据库连接池"""

    def __init__(self, max_connections: int = 5) -> None:
        self.max_connections = max_connections
        self.connections: "asyncio.Queue[sqlite3.Connection]" = asyncio.Queue(maxsize=max_connections)
        self.connection_params: Dict[str, Any] = {}

    async def initialize(self, db_path: Path):
        """初始化连接池"""
        for _ in range(self.max_connections):
            conn = sqlite3.connect(db_path)
            conn.execute("PRAGMA journal_mode=WAL")  # 启用WAL模式提高并发性能
            conn.execute("PRAGMA synchronous=NORMAL")  # 平衡性能和安全性
            conn.execute("PRAGMA cache_size=10000")  # 设置缓存大小
            conn.execute("PRAGMA temp_store=memory")  # 临时表存储在内存中
            await self.connections.put(conn)

    async def get_connection(self) -> sqlite3.Connection:
        """获取数据库连接"""
        try:
            conn = await asyncio.wait_for(self.connections.get(), timeout=5.0)
            return conn
        except asyncio.TimeoutError:
            raise RuntimeError("Database connection pool exhausted")

    async def return_connection(self, conn: sqlite3.Connection):
        """归还数据库连接"""
        try:
            await self.connections.put(conn)
        except asyncio.QueueFull:
            conn.close()


class StateManager:
    """修复后的SQLite-based状态管理器，用于跟踪故事进度。"""

    db_path: Path
    _lock: asyncio.Lock
    _deadlock_detector: DeadlockDetector
    _connection_pool: Optional[DatabaseConnectionPool]

    def __init__(self, db_path: str = "progress.db", use_connection_pool: bool = True):
        """
        初始化状态管理器。

        Args:
            db_path: SQLite数据库文件路径
            use_connection_pool: 是否使用连接池
        """
        self.db_path = Path(db_path)
        self._lock = asyncio.Lock()
        self._deadlock_detector = DeadlockDetector()
        self._connection_pool = DatabaseConnectionPool() if use_connection_pool else None

        self._init_db_sync()

        # 初始化连接池
        if self._connection_pool:
            asyncio.create_task(self._connection_pool.initialize(self.db_path))

    def _init_db_sync(self):
        """初始化数据库模式（同步）。"""
        # 使用连接池时，所有连接都需要初始化
        if self._connection_pool:
            conn = sqlite3.connect(self.db_path)
        else:
            conn = sqlite3.connect(self.db_path)

        cursor = conn.cursor()

        # 创建stories表
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS stories (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                epic_path TEXT NOT NULL,
                story_path TEXT NOT NULL UNIQUE,
                status TEXT NOT NULL,
                iteration INTEGER DEFAULT 0,
                qa_result TEXT,
                error_message TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                phase TEXT,
                version INTEGER DEFAULT 1
            )
        ''')

        # 创建索引
        cursor.execute('''
            CREATE INDEX IF NOT EXISTS idx_story_path
            ON stories(story_path)
        ''')

        cursor.execute('''
            CREATE INDEX IF NOT EXISTS idx_status
            ON stories(status)
        ''')

        # 创建其他表...
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS code_quality_phase (
                record_id TEXT PRIMARY KEY,
                epic_id TEXT NOT NULL,
                file_path TEXT NOT NULL,
                error_count INTEGER DEFAULT 0,
                fix_status TEXT DEFAULT 'pending',
                basedpyright_errors TEXT,
                ruff_errors TEXT,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')

        cursor.execute('''
            CREATE TABLE IF NOT EXISTS test_automation_phase (
                record_id TEXT PRIMARY KEY,
                epic_id TEXT NOT NULL,
                test_file_path TEXT NOT NULL,
                failure_count INTEGER DEFAULT 0,
                fix_status TEXT DEFAULT 'pending',
                debug_info TEXT,
                timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        ''')

        conn.commit()
        conn.close()

        logger.info(f"Database initialized: {self.db_path}")

    @asynccontextmanager
    async def _get_db_connection(self):
        """获取数据库连接的上下文管理器"""
        if self._connection_pool:
            conn = await self._connection_pool.get_connection()
            try:
                yield conn
            finally:
                await self._connection_pool.return_connection(conn)
        else:
            conn = sqlite3.connect(self.db_path)
            try:
                yield conn
            finally:
                conn.close()

    async def update_story_status(
        self,
        story_path: str,
        status: str,
        phase: Union[str, None] = None,
        iteration: Union[int, None] = None,
        qa_result: Union["dict[str, Any]", None] = None,
        error: Union[str, None] = None,
        epic_path: Union[str, None] = None,
        lock_timeout: float = 30.0,
        expected_version: Union[int, None] = None
    ) -> "tuple[bool, Union[int, None]]":
        """
        更新或插入故事状态，优化锁管理和错误处理。

        Args:
            story_path: 故事文件路径
            status: 当前状态
            phase: 当前阶段
            iteration: 当前迭代次数
            qa_result: QA结果字典
            error: 错误消息
            epic_path: Epic文件路径
            lock_timeout: 锁获取超时时间（秒）
            expected_version: 期望的版本号（用于乐观锁）

        Returns:
            (success, current_version): (是否成功, 当前版本号)
        """
        # 使用死锁检测器获取锁
        lock_acquired = await self._deadlock_detector.wait_for_lock(
            f"story_{story_path}", self._lock
        )

        if not lock_acquired:
            logger.error(f"Failed to acquire lock for {story_path} (deadlock detected)")
            return False, None

        try:
            # 验证死锁检测
            if self._deadlock_detector.deadlock_detected:
                logger.error(f"Deadlock detected for {story_path}")
                return False, None

            async with self._lock:
                return await self._update_story_internal(
                    story_path, status, phase, iteration, qa_result, error,
                    epic_path, expected_version
                )

        except asyncio.CancelledError:
            logger.warning(f"Lock acquisition cancelled for {story_path}")
            return False, None
        except Exception as e:
            logger.error(f"Failed to update story status for {story_path}: {e}")
            logger.debug(f"Error details: {e}", exc_info=True)
            return False, None
        finally:
            # 确保锁被释放
            if self._lock.locked():
                self._lock.release()

    async def _update_story_internal(
        self,
        story_path: str,
        status: str,
        phase: Union[str, None],
        iteration: Union[int, None],
        qa_result: Union["dict[str, Any]", None],
        error: Union[str, None],
        epic_path: Union[str, None],
        expected_version: Union[int, None]
    ) -> "tuple[bool, Union[int, None]]":
        """内部更新逻辑"""
        async with self._get_db_connection() as conn:
            cursor = conn.cursor()

            # 检查故事是否存在
            cursor.execute(
                'SELECT id, version FROM stories WHERE story_path = ?',
                (story_path,)
            )
            existing = cursor.fetchone()

            # 清理qa_result
            qa_result_str = None
            if qa_result:
                qa_result_str = self._clean_qa_result_for_json(qa_result)

            if existing:
                _, current_version = existing

                # 乐观锁检查
                if expected_version is not None and current_version != expected_version:
                    logger.warning(
                        f"Version conflict for {story_path}: "
                        f"expected {expected_version}, got {current_version}"
                    )
                    return False, current_version

                # 更新现有记录
                cursor.execute('''
                    UPDATE stories
                    SET status = ?,
                        phase = ?,
                        iteration = ?,
                        qa_result = ?,
                        error_message = ?,
                        updated_at = CURRENT_TIMESTAMP,
                        version = version + 1
                    WHERE story_path = ?
                ''', (
                    status,
                    phase,
                    iteration,
                    qa_result_str,
                    error,
                    story_path
                ))
                logger.info(f"Updated status for {story_path}: {status} (version {current_version + 1})")
                current_version = current_version + 1
            else:
                # 插入新记录
                cursor.execute('''
                    INSERT INTO stories
                    (epic_path, story_path, status, phase, iteration, qa_result, error_message, version)
                    VALUES (?, ?, ?, ?, ?, ?, ?, 1)
                ''', (
                    epic_path or '',
                    story_path,
                    status,
                    phase,
                    iteration or 0,
                    qa_result_str,
                    error
                ))
                logger.info(f"Inserted new record for {story_path}: {status} (version 1)")
                current_version = 1

            conn.commit()
            return True, current_version

    def _clean_qa_result_for_json(self, qa_result: Any) -> Optional[str]:
        """清理QA结果以便JSON序列化"""
        try:
            # 移除不可序列化的对象
            def clean_for_json(obj: Any) -> Any:
                if hasattr(obj, 'value'):
                    return obj.value
                elif isinstance(obj, dict):
                    return {str(k): clean_for_json(v) for k, v in obj.items()}  # type: ignore[var-annotated]
                elif isinstance(obj, list):
                    return [clean_for_json(item) for item in obj]  # type: ignore[var-annotated]
                else:
                    return obj

            cleaned_qa_result = clean_for_json(qa_result)
            return json.dumps(cleaned_qa_result)
        except Exception as e:
            logger.warning(f"Failed to clean QA result for JSON: {e}")
            return None

    @asynccontextmanager
    async def managed_operation(self):
        """
        异步上下文管理器，用于安全锁管理。

        确保即使发生取消也能正确释放锁。
        """
        lock_acquired = False
        try:
            # 使用死锁检测
            lock_acquired = await self._deadlock_detector.wait_for_lock(
                "managed_operation", self._lock
            )

            if lock_acquired:
                yield self
            else:
                logger.error("Failed to acquire lock for managed operation")
                raise RuntimeError("Failed to acquire lock")
        except asyncio.CancelledError:
            logger.warning("Managed operation cancelled, releasing lock")
            if lock_acquired and self._lock.locked():
                self._lock.release()
            # 不重新抛出以避免cancel scope错误
            return
        except Exception as e:
            logger.error(f"Managed operation failed: {e}")
            if lock_acquired and self._lock.locked():
                self._lock.release()
            raise
        finally:
            # 确保锁被释放
            if lock_acquired and self._lock.locked():
                self._lock.release()

    async def get_story_status(self, story_path: str) -> Union["dict[str, Any]", None]:
        """
        获取故事状态。

        Args:
            story_path: 故事文件路径

        Returns:
            包含故事状态和元数据的字典，如果未找到则返回None
        """
        try:
            async with self._lock:
                async with self._get_db_connection() as conn:
                    cursor = conn.cursor()

                    cursor.execute('''
                        SELECT epic_path, story_path, status, iteration, qa_result,
                               error_message, created_at, updated_at, phase, version
                        FROM stories
                        WHERE story_path = ?
                    ''', (story_path,))

                    row = cursor.fetchone()

                    if row:
                        result = {
                            'epic_path': row[0],
                            'story_path': row[1],
                            'status': row[2],
                            'iteration': row[3],
                            'created_at': row[6],
                            'updated_at': row[7],
                            'phase': row[8],
                            'version': row[9]
                        }

                        if row[4]:  # qa_result
                            try:
                                result['qa_result'] = json.loads(row[4])
                            except json.JSONDecodeError:
                                result['qa_result'] = row[4]

                        if row[5]:  # error_message
                            result['error'] = row[5]

                        return result

                    return None

        except Exception as e:
            logger.error(f"Failed to get story status: {e}")
            logger.debug(f"Error details: {e}", exc_info=True)
            return None

    async def get_all_stories(self) -> "list[dict[str, Any]]":
        """
        获取所有故事。

        Returns:
            故事字典列表
        """
        try:
            async with self._lock:
                async with self._get_db_connection() as conn:
                    cursor = conn.cursor()

                    cursor.execute('''
                        SELECT epic_path, story_path, status, iteration, qa_result,
                               error_message, created_at, updated_at, phase, version
                        FROM stories
                        ORDER BY created_at
                    ''')

                    rows = cursor.fetchall()
                    stories: list[dict[str, Any]] = []

                    for row in rows:
                        story: dict[str, Any] = {
                            'epic_path': row[0],
                            'story_path': row[1],
                            'status': row[2],
                            'iteration': row[3],
                            'created_at': row[6],
                            'updated_at': row[7],
                            'phase': row[8],
                            'version': row[9]
                        }

                        if row[4]:  # qa_result
                            try:
                                story['qa_result'] = json.loads(row[4])
                            except json.JSONDecodeError:
                                story['qa_result'] = row[4]

                        if row[5]:  # error_message
                            story['error'] = row[5]

                        stories.append(story)

                    return stories

        except Exception as e:
            logger.error(f"Failed to get all stories: {e}")
            logger.debug(f"Error details: {e}", exc_info=True)
            return []

    async def get_stats(self) -> "dict[str, int]":
        """
        获取故事状态统计。

        Returns:
            包含状态计数的字典
        """
        try:
            async with self._lock:
                async with self._get_db_connection() as conn:
                    cursor = conn.cursor()

                    cursor.execute('''
                        SELECT status, COUNT(*) as count
                        FROM stories
                        GROUP BY status
                    ''')

                    rows = cursor.fetchall()
                    stats: dict[str, int] = {}
                    for status, count in rows:
                        stats[status] = count

                    return stats

        except Exception as e:
            logger.error(f"Failed to get stats: {e}")
            logger.debug(f"Error details: {e}", exc_info=True)
            return {}

    async def create_backup(self) -> Union[str, None]:
        """
        创建数据库备份。

        Returns:
            备份文件路径，如果失败则返回None
        """
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_path = self.db_path.parent / f"{self.db_path.stem}_backup_{timestamp}{self.db_path.suffix}"

            # 使用文件复制而不是数据库备份，因为SQLite支持热备份
            shutil.copy2(self.db_path, backup_path)

            logger.info(f"Database backup created: {backup_path}")
            return str(backup_path)

        except Exception as e:
            logger.error(f"Failed to create backup: {e}")
            logger.debug(f"Error details: {e}", exc_info=True)
            return None

    async def cleanup_old_records(self, days: int = 30) -> int:
        """
        清理旧记录。

        Args:
            days: 保留天数

        Returns:
            清理的记录数
        """
        try:
            async with self._lock:
                async with self._get_db_connection() as conn:
                    cursor = conn.cursor()

                    # 清理旧的stories记录
                    cursor.execute('''
                        DELETE FROM stories
                        WHERE updated_at < datetime('now', '-{} days')
                        AND status IN ('completed', 'failed')
                    '''.format(days))

                    deleted_count = cursor.rowcount

                    # 清理其他表的旧记录
                    cursor.execute('''
                        DELETE FROM code_quality_phase
                        WHERE timestamp < datetime('now', '-{} days')
                    '''.format(days))

                    deleted_count += cursor.rowcount

                    cursor.execute('''
                        DELETE FROM test_automation_phase
                        WHERE timestamp < datetime('now', '-{} days')
                    '''.format(days))

                    deleted_count += cursor.rowcount

                    conn.commit()

                    logger.info(f"Cleaned up {deleted_count} old records")
                    return deleted_count

        except Exception as e:
            logger.error(f"Failed to cleanup old records: {e}")
            logger.debug(f"Error details: {e}", exc_info=True)
            return 0

    async def add_quality_phase_record(
        self,
        epic_id: str,
        file_path: str,
        error_count: int,
        basedpyright_errors: str,
        ruff_errors: str,
        fix_status: str
    ) -> bool:
        """
        添加代码质量阶段记录。

        Args:
            epic_id: Epic标识符
            file_path: 文件路径
            error_count: 错误数量
            basedpyright_errors: BasedPyright错误信息(JSON字符串)
            ruff_errors: Ruff错误信息(JSON字符串)
            fix_status: 修复状态

        Returns:
            成功返回True，失败返回False
        """
        try:
            async with self._lock:
                async with self._get_db_connection() as conn:
                    cursor = conn.cursor()

                    # 生成唯一记录ID
                    record_id = str(uuid.uuid4())

                    # 插入记录
                    cursor.execute('''
                        INSERT INTO code_quality_phase
                        (record_id, epic_id, file_path, error_count, fix_status, basedpyright_errors, ruff_errors)
                        VALUES (?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        record_id,
                        epic_id,
                        file_path,
                        error_count,
                        fix_status,
                        basedpyright_errors,
                        ruff_errors
                    ))

                    conn.commit()
                    logger.debug(f"Added quality phase record: {record_id} for {file_path}")
                    return True

        except Exception as e:
            logger.error(f"Failed to add quality phase record: {e}")
            logger.debug(f"Error details: {e}", exc_info=True)
            return False

    def get_health_status(self) -> "dict[str, Any]":
        """
        获取数据库健康状态。

        Returns:
            健康状态字典
        """
        try:
            return {
                "db_path": str(self.db_path),
                "db_exists": self.db_path.exists(),
                "lock_locked": self._lock.locked(),
                "deadlock_detected": self._deadlock_detector.deadlock_detected,
                "connection_pool_enabled": self._connection_pool is not None,
                "connection_pool_size": self._connection_pool.max_connections if self._connection_pool else 0
            }
        except Exception as e:
            logger.error(f"Failed to get health status: {e}")
            return {"error": str(e)}
