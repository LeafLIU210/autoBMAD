"""
ä¿®å¤åŽçš„SDKåŒ…è£…å™¨ - Fixed SDK Wrapper with Cancellation Manager Integration

è§£å†³cancel scopeè·¨ä»»åŠ¡é”™è¯¯å’Œå¼‚æ­¥ç”Ÿæˆå™¨ç”Ÿå‘½å‘¨æœŸç®¡ç†é—®é¢˜ã€‚
åŸºäºŽåŽŸç‰ˆæœ¬ï¼šd:\\GITHUB\\pytQt_template\\autoBMAD\\epic_automation\\sdk_wrapper.py

ä¸»è¦ä¿®å¤ï¼š
1. è§£å†³cancel scopeè·¨ä»»åŠ¡é”™è¯¯
2. é›†æˆSDKå–æ¶ˆç®¡ç†å™¨ï¼ˆç»Ÿä¸€ç®¡ç†ï¼‰
3. ä¼˜åŒ–å¼‚æ­¥ç”Ÿæˆå™¨ç”Ÿå‘½å‘¨æœŸç®¡ç†
4. å¢žå¼ºé”™è¯¯æ¢å¤æœºåˆ¶
5. æ”¹è¿›èµ„æºæ¸…ç†é€»è¾‘
6. ç§»é™¤åˆ†æ•£çš„å–æ¶ˆåˆ¤æ–­é€»è¾‘ï¼ˆç¬¦åˆå¥¥å¡å§†å‰ƒåˆ€åŽŸåˆ™ï¼‰
"""

import asyncio
import logging
import time
import traceback
from collections.abc import AsyncIterator
from pathlib import Path
from typing import Any, TypeVar

# Type aliases for SDK Classes
try:  # type: ignore[import-untyped, import-untyped-missing, reportMissingImports]
    from claude_agent_sdk import ResultMessage, query

    _query = query
    _ResultMessage = ResultMessage
    _sdk_available = True  # type: ignore
except ImportError:
    _query = None  # type: ignore
    _ResultMessage = None  # type: ignore
    _sdk_available = False  # type: ignore

# Re-export with proper types
query = _query
ResultMessage = _ResultMessage

# Import Claude SDK types for proper type checking
try:  # type: ignore[import-untyped, import-untyped-missing, reportMissingImports]
    from claude_agent_sdk import (
        AssistantMessage as _AssistantMessage,
    )
    from claude_agent_sdk import (
        SystemMessage as _SystemMessage,
    )  # noqa: F401  # Imported for type checking, used via duck typing
    from claude_agent_sdk import (
        TextBlock as _TextBlock,
    )
    from claude_agent_sdk import (
        ThinkingBlock as _ThinkingBlock,
    )
    from claude_agent_sdk import (
        ToolResultBlock as _ToolResultBlock,
    )
    from claude_agent_sdk import (
        ToolUseBlock as _ToolUseBlock,
    )
    from claude_agent_sdk import (
        UserMessage as _UserMessage,
    )

    _claude_types_available = True
except ImportError:
    # Fallback types for when SDK is not available
    _SystemMessage = None  # type: ignore[misc]
    _AssistantMessage = None  # type: ignore[misc]
    _UserMessage = None  # type: ignore[misc]
    _TextBlock = None  # type: ignore[misc]
    _ThinkingBlock = None  # type: ignore[misc]
    _ToolUseBlock = None  # type: ignore[misc]
    _ToolResultBlock = None  # type: ignore[misc]
    _claude_types_available = False

# Re-export with proper names (kept for backward compatibility)
SystemMessage = _SystemMessage
AssistantMessage = _AssistantMessage
UserMessage = _UserMessage
TextBlock = _TextBlock
ThinkingBlock = _ThinkingBlock
ToolUseBlock = _ToolUseBlock
ToolResultBlock = _ToolResultBlock

# Export constants for backward compatibility
SDK_AVAILABLE = _sdk_available
CLAUDE_TYPES_AVAILABLE = _claude_types_available

logger = logging.getLogger(__name__)

# Type variable for generic async generator
_T = TypeVar("_T")


class SDKExecutionError(Exception):
    """SDKæ‰§è¡Œé”™è¯¯å¼‚å¸¸"""

    pass


class SafeAsyncGenerator:
    """å®‰å…¨çš„å¼‚æ­¥ç”Ÿæˆå™¨åŒ…è£…å™¨"""

    def __init__(
        self, generator: AsyncIterator[Any], cleanup_timeout: float = 1.0
    ) -> None:
        self.generator = generator
        self.cleanup_timeout = cleanup_timeout
        self._closed = False

    def __aiter__(self) -> "SafeAsyncGenerator":
        """å¼‚æ­¥è¿­ä»£å™¨"""
        return self

    async def __anext__(self) -> Any:
        """å¼‚æ­¥ä¸‹ä¸€é¡¹"""
        if self._closed:
            raise StopAsyncIteration

        try:
            return await self.generator.__anext__()
        except StopAsyncIteration:
            self._closed = True
            raise
        except Exception as e:
            logger.error(f"Error in async generator: {e}")
            logger.debug(traceback.format_exc())
            await self.aclose()
            raise

    async def aclose(self) -> None:
        """å¢žå¼ºçš„å¼‚æ­¥ç”Ÿæˆå™¨æ¸…ç† - é˜²æ­¢ cancel scope è·¨ä»»åŠ¡é”™è¯¯

        å…³é”®ä¿®å¤ï¼š
        1. æ·»åŠ äº‹ä»¶å¾ªçŽ¯çŠ¶æ€æ£€æµ‹
        2. å®‰å…¨å¤„ç† cancel scope é”™è¯¯
        3. é˜²æ­¢è·¨ä»»åŠ¡è®¿é—®å†²çª
        4. ç¡®ä¿æ¸…ç†è¿‡ç¨‹ä¸ä¼šæŠ›å‡ºæœªå¤„ç†çš„å¼‚å¸¸
        5. ç¡®ä¿æ‰€æœ‰pendingæ“ä½œå®Œå…¨ç»“æŸ
        """
        if self._closed:
            return

        self._closed = True

        try:
            # æ£€æµ‹äº‹ä»¶å¾ªçŽ¯çŠ¶æ€
            loop = asyncio.get_running_loop()
            loop_running = not loop.is_closed()

            if not loop_running:
                logger.debug("Event loop is closed, skipping generator cleanup")
                return

            # èŽ·å–åŽŸå§‹ç”Ÿæˆå™¨çš„ aclose æ–¹æ³•
            aclose = getattr(self.generator, "aclose", None)
            if aclose and callable(aclose):
                try:
                    result = aclose()
                    if result is not None:
                        # ðŸŽ¯ å…³é”®ä¿®å¤ï¼šç¡®ä¿åœ¨æ­£ç¡®çš„ä»»åŠ¡ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œ
                        if asyncio.iscoroutine(result):
                            await result
                except (TypeError, AttributeError) as e:
                    logger.debug(f"Generator cleanup (non-critical): {e}")
                except asyncio.CancelledError:
                    # è®°å½•ä½†ä¸é‡æ–°æŠ›å‡ºï¼Œé¿å… scope å†²çª
                    logger.debug("Generator cleanup cancelled (ignored)")
                except RuntimeError as e:
                    error_msg = str(e)
                    # ðŸŽ¯ å…³é”®ä¿®å¤ï¼šè¯†åˆ«å¹¶å®‰å…¨å¤„ç† cancel scope é”™è¯¯
                    if "cancel scope" in error_msg or "Event loop is closed" in error_msg:
                        logger.debug(f"Expected SDK shutdown error (suppressed): {error_msg}")
                        # ç¡®ä¿æ¸…ç†å®ŒæˆåŽå†è¿”å›ž
                        await self._ensure_cleanup_complete()
                        return  # è¿”å›žè€Œä¸æ˜¯æŠ›å‡ºï¼Œé˜²æ­¢å´©æºƒ
                    else:
                        logger.debug(f"Generator cleanup RuntimeError: {e}")
                        raise
                except Exception as e:
                    # æ•èŽ·æ¸…ç†è¿‡ç¨‹ä¸­çš„ä»»ä½•å…¶ä»–å¼‚å¸¸
                    logger.debug(f"Generator cleanup exception: {e}")
        except Exception as e:
            logger.debug(f"Generator cleanup error: {e}")
        finally:
            # ðŸŽ¯ ç¡®ä¿æ¸…ç†å®Œå…¨ç»“æŸ
            try:
                await asyncio.sleep(0.05)  # çŸ­æš‚ç­‰å¾…ç¡®ä¿æ‰€æœ‰æ¸…ç†å®Œæˆ
            except Exception:
                pass  # å¿½ç•¥æ¸…ç†å®Œæˆæ£€æŸ¥ä¸­çš„é”™è¯¯

    async def _ensure_cleanup_complete(self) -> None:
        """ðŸŽ¯ ç¡®ä¿æ¸…ç†å®Œå…¨ç»“æŸ"""
        try:
            # ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®ä¿æ¸…ç†å®Œæˆ
            await asyncio.sleep(0.1)
            logger.debug("SDK cleanup completed")
        except Exception as e:
            logger.debug(f"Cleanup completion check failed: {e}")


class SDKMessageTracker:
    """Tracks latest SDK message and periodically displays it."""

    def __init__(self, log_manager: Any | None = None):
        self.latest_message: str | None = None
        self.message_type: str = "INFO"
        self.message_count: int = 0
        self.start_time: float = time.time()
        self._stop_event: asyncio.Event = asyncio.Event()
        self._display_task: asyncio.Task[None] | None = None
        self.log_manager = log_manager

    def update_message(self, message: str, msg_type: str = "INFO"):
        """Update the latest message and its type."""
        self.latest_message = message
        self.message_type = msg_type
        self.message_count += 1

        # Write to log file if log_manager is available
        if self.log_manager:
            try:
                self.log_manager.write_sdk_message(message, msg_type)
            except Exception as e:
                logger.debug(f"Failed to write SDK message to log: {e}")

        # Output to console for real-time display (will be captured by DualWriteStream)
        print(f"[{msg_type}] {message}")

    def get_elapsed_time(self) -> float:
        """Get elapsed time since start."""
        return time.time() - self.start_time

    async def start_periodic_display(self):
        """Start periodic display of latest message every 30 seconds."""
        # Only create task if not already created
        if self._display_task is None or self._display_task.done():
            self._stop_event.clear()  # Reset stop event
            # Create task and shield the coroutine from external cancellation
            self._display_task = asyncio.create_task(self._periodic_display())

    async def stop_periodic_display(self, timeout: float = 1.0):
        """Stop the periodic display using Event signaling instead of task cancellation."""
        self._stop_event.set()
        if self._display_task and not self._display_task.done():
            try:
                # Wait for task to exit naturally using Event signal
                await asyncio.wait_for(self._display_task, timeout=timeout)
            except TimeoutError:
                # Task didn't exit in time, but stop_event is set so it will exit on next iteration
                logger.debug(
                    "Display task exit timeout (acceptable - will exit naturally)"
                )
            except Exception as e:
                logger.debug(f"Error waiting for display task to exit: {e}")
            finally:
                self._display_task = None

    def signal_stop(self):
        """
        Signal the periodic display to stop via the internal stop event.

        This method provides a safe way to trigger the stop event without
        direct access to the private _stop_event attribute.
        """
        self._stop_event.set()

    async def _periodic_display(self):
        """Display latest message every 30 seconds."""
        try:
            while not self._stop_event.is_set():
                try:
                    await asyncio.wait_for(self._stop_event.wait(), timeout=30.0)
                    break  # Stop event was set
                except TimeoutError:
                    # 30 seconds passed, display latest message
                    if self.latest_message and not self._stop_event.is_set():
                        elapsed = self.get_elapsed_time()
                        # Clean display format: [Type] Message content
                        logger.info(
                            f"[{self.message_type}] {self.latest_message} (after {elapsed:.1f}s)"
                        )
        except asyncio.CancelledError:
            # Task was cancelled, exit gracefully without raising
            logger.debug("Periodic display task was cancelled")
            # Don't re-raise CancelledError to prevent scope issues
            return
        except Exception as e:
            # Log any unexpected errors but don't crash
            logger.debug(f"Error in periodic display: {e}")

    def display_final_summary(self):
        """Display final summary when complete."""
        elapsed = self.get_elapsed_time()
        logger.info(
            f"[COMPLETE] SDK execution finished with {self.message_count} messages in {elapsed:.1f}s"
        )


class SafeClaudeSDK:
    """
    Fixed safe wrapper for Claude SDK with unified cancellation management.

    This wrapper ensures proper cleanup of async generators and prevents
    RuntimeError when event loop closes. Now integrated with SDKCancellationManager
    for unified cancellation handling.

    Major fixes:
    1. Integration with SDKCancellationManager (unified management)
    2. Task isolation for generator lifecycle
    3. Enhanced error recovery
    4. Safe resource cleanup
    5. Cross-task cancel scope protection
    6. Removed distributed cancellation logic (éµå¾ªå¥¥å¡å§†å‰ƒåˆ€åŽŸåˆ™)
    """

    def __init__(
        self,
        prompt: str,
        options: Any,
        timeout: float | None = None,
        log_manager: Any | None = None,
    ):
        self.prompt: str = prompt
        self.options: Any = options
        self.timeout: float | None = timeout
        self.message_tracker: SDKMessageTracker = SDKMessageTracker(log_manager)
        self.log_manager = log_manager

    def _extract_message_content(self, message: Any) -> str | None:
        """Extract actual content from Claude SDK messages - unified method."""
        try:
            # Get message class name for unified handling
            msg_class = (
                message.__class__.__name__
                if hasattr(message, "__class__")
                else "Unknown"
            )

            # Handle AssistantMessage - Claude's actual responses
            if msg_class == "AssistantMessage" and hasattr(message, "content"):
                return self._extract_assistant_content(message)
            # Handle SystemMessage - System initialization/info
            elif msg_class == "SystemMessage":
                return self._extract_system_content(message)
            # Handle UserMessage - User inputs
            elif msg_class == "UserMessage":
                return self._extract_user_content(message)
            # Handle ResultMessage - Final results
            elif msg_class == "ResultMessage":
                return self._extract_result_content(message)

        except Exception as e:
            logger.debug(f"Failed to extract message content: {e}")
        return None

    def _extract_assistant_content(self, message: Any) -> str | None:
        """Extract content from AssistantMessage."""
        if not hasattr(message, "content") or not isinstance(message.content, list):
            return None

        content_parts: list[str] = []
        content_list: list[Any] = message.content  # type: ignore[assignment]
        for block in content_list:
            block_item: Any = block
            block_type: str = str(block_item.__class__.__name__)

            if block_type == "TextBlock" and hasattr(block_item, "text"):
                text_value: str = str(getattr(block_item, "text", ""))
                if text_value:
                    content_parts.append(text_value.strip())
            elif block_type == "ThinkingBlock" and hasattr(block_item, "thinking"):
                thinking_value: str = str(getattr(block_item, "thinking", ""))
                if thinking_value:
                    thinking_text: str = thinking_value.strip()
                    preview: str = (
                        thinking_text[:150] + "..."
                        if len(thinking_text) > 150
                        else thinking_text
                    )
                    content_parts.append(f"[Thinking] {preview}")
            elif block_type == "ToolUseBlock" and hasattr(block_item, "name"):
                tool_name: str = str(getattr(block_item, "name", "unknown"))
                content_parts.append(f"[Using tool: {tool_name}]")
            elif block_type == "ToolResultBlock" and hasattr(block_item, "content"):
                tool_content: Any = getattr(block_item, "content", None)
                if tool_content:
                    if isinstance(tool_content, str) and tool_content.strip():
                        content_parts.append(f"[Tool result] {tool_content.strip()}")
                    elif isinstance(tool_content, list):
                        result_count: int = len(tool_content)  # type: ignore[arg-type]
                        if result_count > 0:
                            content_parts.append(
                                f"[Tool completed with {result_count} results]"
                            )

        return " ".join(content_parts) if content_parts else None

    def _extract_system_content(self, message: Any) -> str | None:
        """Extract content from SystemMessage."""
        if not hasattr(message, "subtype"):
            return None

        subtype: str = str(getattr(message, "subtype", "unknown"))
        if hasattr(message, "data") and isinstance(message.data, dict):  # type: ignore[union-attr]
            data_dict: dict[str, Any] = message.data  # type: ignore[assignment]
            if subtype == "init":
                session_id: str = str(data_dict.get("session_id", "unknown"))
                model: str = str(data_dict.get("model", "unknown"))
                return (
                    f"[System initialized] Model: {model}, Session: {session_id[:8]}..."
                )
            elif subtype == "tool":
                tool_name: str = str(data_dict.get("tool", "unknown"))
                return f"[System] Tool: {tool_name}"
        return f"[System] {subtype}"

    def _extract_user_content(self, message: Any) -> str | None:
        """Extract content from UserMessage."""
        if not hasattr(message, "content"):
            return None

        content: Any = message.content  # type: ignore[union-attr]
        if isinstance(content, str) and content.strip():
            return f"[User] {content.strip()[:100]}..."
        elif isinstance(content, list):
            block_count: int = len(content)  # type: ignore[arg-type]
            return f"[User sent {block_count} content blocks]"
        return None

    def _extract_result_content(self, message: Any) -> str | None:
        """Extract content from ResultMessage."""
        if hasattr(message, "is_error"):
            if message.is_error:
                error_result = getattr(message, "result", "Unknown error")
                return f"[Error] {error_result}"
            else:
                success_result = getattr(message, "result", "Success")
                if isinstance(success_result, str) and len(success_result) > 200:
                    return f"[Success] {success_result[:200]}..."
                else:
                    return f"[Success] {success_result}"

        if hasattr(message, "num_turns"):
            turns = getattr(message, "num_turns", 0)
            duration = getattr(message, "duration_ms", 0) / 1000
            return f"[Complete] {turns} turns, {duration:.1f}s"
        return None

    def _classify_message_type(self, message: Any) -> str:
        """Classify the type of message from Claude SDK - simplified."""
        try:
            msg_class = (
                message.__class__.__name__
                if hasattr(message, "__class__")
                else "Unknown"
            )

            if msg_class == "SystemMessage":
                subtype = getattr(message, "subtype", "unknown")
                if subtype == "init":
                    return "INIT"
                elif subtype == "tool":
                    return "TOOL"
                return "SYSTEM"

            elif msg_class == "AssistantMessage":
                if hasattr(message, "content") and isinstance(message.content, list):  # type: ignore
                    for block in message.content:  # type: ignore
                        block_type = block.__class__.__name__  # type: ignore
                        if block_type == "ThinkingBlock":
                            return "THINKING"
                        elif block_type == "TextBlock":
                            return "ASSISTANT"
                        elif block_type == "ToolUseBlock":
                            return "TOOL_USE"
                        elif block_type == "ToolResultBlock":
                            return "TOOL_RESULT"
                return "ASSISTANT"

            elif msg_class == "UserMessage":
                return "USER"

            elif msg_class == "ResultMessage":
                if hasattr(message, "is_error") and message.is_error:
                    return "ERROR"
                return "SUCCESS"

            return "INFO"

        except Exception as e:
            logger.debug(f"Failed to classify message type: {e}")
            return "INFO"

    async def execute(self) -> bool:
        """
        Execute Claude SDK query with unified cancellation management.

        ðŸŽ¯ å…³é”®æ”¹å˜ï¼š
        1. ç§»é™¤æ‰€æœ‰æœ¬åœ°å–æ¶ˆåˆ¤æ–­é€»è¾‘
        2. å®Œå…¨å§”æ‰˜ç»™ SDKCancellationManager
        3. ä¸å†åœ¨æ­¤å¤„å¤„ç† cancel scope é”™è¯¯

        Returns:
            True if execution succeeded, False otherwise
        """
        if not SDK_AVAILABLE:
            logger.warning("Claude Agent SDK not available")
            return False

        # ðŸŽ¯ å”¯ä¸€å…¥å£ï¼šèŽ·å–å…¨å±€ç®¡ç†å™¨
        try:
            from autoBMAD.epic_automation.monitoring import get_cancellation_manager
            manager = get_cancellation_manager()
        except ImportError as e:
            logger.warning(f"Could not import cancellation manager: {e}")
            # Fallback to old behavior
            return await self._execute_safely()

        # ç”Ÿæˆå”¯ä¸€è°ƒç”¨ ID
        call_id = f"sdk_{id(self)}_{int(time.time() * 1000)}"

        try:
            # ðŸŽ¯ æ‰€æœ‰ SDK æ‰§è¡Œéƒ½å¿…é¡»é€šè¿‡ç®¡ç†å™¨è¿½è¸ª
            async with manager.track_sdk_execution(
                call_id=call_id,
                operation_name="sdk_execute",
                context={
                    "prompt_length": len(self.prompt),
                    "has_options": self.options is not None
                }
            ):
                result = await self._execute_safely_with_manager(manager, call_id)
                return result

        except asyncio.CancelledError:
            # ðŸŽ¯ ç»Ÿä¸€å¤„ç†ï¼šå®Œå…¨å§”æ‰˜ç»™ç®¡ç†å™¨å†³ç­–
            cancel_type = manager.check_cancellation_type(call_id)

            if cancel_type == "after_success":
                # ç®¡ç†å™¨ç¡®è®¤å·¥ä½œå·²å®Œæˆï¼Œç­‰å¾…æ¸…ç†å®Œæˆ
                await manager.wait_for_cancellation_complete(call_id, timeout=5.0)
                logger.info(
                    "[SafeClaudeSDK] Cancellation suppressed - "
                    "SDK completed successfully (confirmed by manager)"
                )
                return True

            # çœŸæ­£çš„å–æ¶ˆ
            logger.warning("SDK execution was cancelled (confirmed by manager)")
            # ç­‰å¾…æ¸…ç†å®Œæˆ
            await manager.wait_for_cancellation_complete(call_id, timeout=5.0)
            raise

        except Exception as e:
            logger.error(f"Claude SDK execution failed: {e}")
            logger.debug(traceback.format_exc())
            return False

    async def _execute_safely_with_manager(
        self,
        manager: Any,
        call_id: str
    ) -> bool:
        """
        Execute with cancellation manager integration.

        Args:
            manager: Cancellation manager instance
            call_id: Unique call identifier

        Returns:
            True if successful, False otherwise
        """
        if query is None or self.options is None:
            logger.warning("Claude SDK not properly initialized")
            return False

        logger.info("[SDK Start] Starting Claude SDK execution with tracking")
        logger.info(f"[SDK Config] Prompt length: {len(self.prompt)} characters")

        # Create query generator
        try:
            generator = query(prompt=self.prompt, options=self.options)  # type: ignore
        except Exception as e:
            logger.error(f"Failed to create SDK query generator: {e}")
            logger.debug(traceback.format_exc())
            return False

        # Wrap generator with safe wrapper
        safe_generator = SafeAsyncGenerator(generator)

        try:
            result = await self._run_isolated_generator_with_manager(
                safe_generator,
                manager,
                call_id
            )
            return result
        except Exception as e:
            logger.error(f"Error in isolated generator execution: {e}")
            logger.debug(traceback.format_exc())
            await safe_generator.aclose()
            return False

    async def _run_isolated_generator_with_manager(
        self,
        safe_generator: SafeAsyncGenerator,
        manager: Any,
        call_id: str
    ) -> bool:
        """
        Run generator with cancellation manager result tracking.

        ðŸŽ¯ å…³é”®æ”¹è¿›ï¼šç«‹å³æ ‡è®°ç»“æžœæŽ¥æ”¶
        """
        message_count = 0
        start_time = asyncio.get_running_loop().time()

        try:
            await self.message_tracker.start_periodic_display()

            async for message in safe_generator:
                message_count += 1

                message_content = self._extract_message_content(message)
                message_type = self._classify_message_type(message)

                if message_content:
                    self.message_tracker.update_message(message_content, message_type)

                if ResultMessage is not None and isinstance(message, ResultMessage):
                    if hasattr(message, "is_error") and message.is_error:
                        error_msg = getattr(message, "result", "Unknown error")
                        logger.error(f"[SDK Error] Claude SDK error: {error_msg}")
                        return False
                    else:
                        result = getattr(message, "result", None)
                        result_str = str(result) if result else "No content"

                        # ðŸŽ¯ å…³é”®ï¼šç«‹å³æ ‡è®°ç»“æžœæŽ¥æ”¶
                        manager.mark_result_received(call_id, result_str)

                        logger.info(f"[SDK Success] Claude SDK result: {result_str[:100]}")
                        return True

            # æ²¡æœ‰æ”¶åˆ° ResultMessage
            total_elapsed = asyncio.get_running_loop().time() - start_time

            await self.message_tracker.stop_periodic_display()

            if message_count > 0:
                logger.info(
                    f"[SDK Complete] Completed with {message_count} messages "
                    f"in {total_elapsed:.1f}s"
                )
                return True
            else:
                logger.error(f"[SDK Failed] No messages received after {total_elapsed:.1f}s")
                return False

        except StopAsyncIteration:
            logger.info("Claude SDK generator completed")
            return True

        except asyncio.CancelledError:
            logger.warning("Claude SDK execution was cancelled")

            try:
                await self.message_tracker.stop_periodic_display()
            except Exception as e:
                logger.debug(f"Error stopping display task: {e}")

            # ðŸŽ¯ é‡æ–°æŠ›å‡ºï¼Œè®©å¤–å±‚æ£€æŸ¥å–æ¶ˆç±»åž‹
            raise

        except Exception as e:
            logger.error(f"Claude SDK execution error: {e}")
            try:
                await self.message_tracker.stop_periodic_display()
            except Exception as cleanup_error:
                logger.debug(f"Error during cleanup: {cleanup_error}")
            raise

        finally:
            await safe_generator.aclose()

    # ä¿ç•™åŽŸæœ‰çš„_execute_safelyæ–¹æ³•ä½œä¸ºåŽå¤‡
    async def _execute_safely(self) -> bool:
        """
        Legacy execute method (fallback when manager is not available).
        """
        if query is None or self.options is None:
            logger.warning("Claude SDK not properly initialized")
            return False

        logger.info("[SDK Start] Starting Claude SDK execution")
        logger.info(f"[SDK Config] Options: {self.options}")
        logger.info(f"[SDK Config] Prompt length: {len(self.prompt)} characters")

        # Create query generator
        try:
            generator = query(prompt=self.prompt, options=self.options)  # type: ignore
        except Exception as e:
            logger.error(f"Failed to create SDK query generator: {e}")
            logger.debug(traceback.format_exc())
            return False

        # Wrap generator with safe wrapper
        safe_generator = SafeAsyncGenerator(generator)

        try:
            result = await self._run_isolated_generator(safe_generator)
            return result
        except Exception as e:
            logger.error(f"Error in isolated generator execution: {e}")
            logger.debug(traceback.format_exc())
            await safe_generator.aclose()
            return False

    async def _run_isolated_generator(self, safe_generator: SafeAsyncGenerator) -> bool:
        """
        Run generator in isolated task with proper error handling.

        Legacy method for backward compatibility.
        """
        message_count = 0
        start_time = asyncio.get_running_loop().time()

        try:
            await self.message_tracker.start_periodic_display()

            async for message in safe_generator:
                message_count += 1

                message_content = self._extract_message_content(message)
                message_type = self._classify_message_type(message)

                if message_content:
                    self.message_tracker.update_message(message_content, message_type)
                else:
                    self.message_tracker.update_message(
                        f"Received {message_type} message {message_count}", message_type
                    )

                if ResultMessage is not None and isinstance(message, ResultMessage):
                    if hasattr(message, "is_error") and message.is_error:
                        error_msg = getattr(message, "result", "Unknown error")
                        self.message_tracker.update_message(
                            f"Error: {error_msg}", "ERROR"
                        )
                        logger.error(f"[SDK Error] Claude SDK error: {error_msg}")
                        return False
                    else:
                        result = getattr(message, "result", None)
                        if result:
                            result_str = str(result)
                            if len(result_str) > 100:
                                result_preview = result_str[:100] + "..."
                            else:
                                result_preview = result_str
                        else:
                            result_preview = "No content"
                        self.message_tracker.update_message(
                            f"Success: {result_preview}", "SUCCESS"
                        )
                        logger.info(
                            f"[SDK Success] Claude SDK result: {result_preview}"
                        )
                        return True

            total_elapsed = asyncio.get_running_loop().time() - start_time

            await self.message_tracker.stop_periodic_display()

            if message_count > 0:
                self.message_tracker.update_message(
                    f"Completed with {message_count} messages", "COMPLETE"
                )
                self.message_tracker.display_final_summary()
                logger.info(
                    f"[SDK Complete] Claude SDK completed with {message_count} messages in {total_elapsed:.1f}s"
                )
                return True
            else:
                prompt_str = str(self.prompt)
                if len(prompt_str) > 100:
                    prompt_preview = prompt_str[:100] + "..."
                else:
                    prompt_preview = prompt_str
                self.message_tracker.update_message(
                    "Failed: No messages received", "ERROR"
                )
                logger.error(
                    f"[SDK Failed] Claude SDK returned no messages after {total_elapsed:.1f}s"
                )
                logger.error(f"[Diagnostic] Prompt preview: {prompt_preview}")
                logger.error(f"[Diagnostic] Options: {self.options}")
                logger.error(f"[Diagnostic] Message count: {message_count}")
                return False

        except StopAsyncIteration:
            logger.info("Claude SDK generator completed")
            return True

        except asyncio.CancelledError:
            logger.warning("Claude SDK execution was cancelled")
            try:
                await self.message_tracker.stop_periodic_display()
            except Exception as e:
                logger.debug(f"Error stopping display task: {e}")
            raise

        except Exception as e:
            logger.error(f"Claude SDK execution error: {e}")
            logger.debug(traceback.format_exc())
            try:
                await self.message_tracker.stop_periodic_display()
            except Exception as cleanup_error:
                logger.debug(f"Error during cleanup: {cleanup_error}")
            raise

        finally:
            await safe_generator.aclose()


# Backward compatibility: keep old class name as alias
SDKWrapper = SafeClaudeSDK
