"""
Dev Agent - Development Agent

Handles development tasks and implementation according to story requirements.
Integrates with task guidance for development-specific operations.
Uses Claude Code CLI for actual implementation.
"""

import asyncio
import logging
import subprocess
import shutil
from typing import Dict, Any, Optional
import re
from pathlib import Path

logger = logging.getLogger(__name__)


class DevAgent:
    """Development agent for handling implementation tasks."""

    def __init__(self, use_claude: bool = True):
        """
        Initialize Dev agent.

        Args:
            use_claude: If True, use Claude Code CLI for real implementation.
                       If False, use simulation mode (for testing).
        """
        self.name = "Dev Agent"
        self.use_claude = use_claude
        self._claude_available = self._check_claude_available() if use_claude else False
        logger.info(f"{self.name} initialized (claude_mode={self.use_claude}, claude_available={self._claude_available})")

    def _check_claude_available(self) -> bool:
        """Check if Claude Code CLI is available."""
        try:
            result = subprocess.run(
                ['claude', '--version'],
                capture_output=True,
                text=True,
                timeout=10,
                shell=True  # Required for Windows
            )
            if result.returncode == 0:
                logger.info(f"Claude Code CLI available: {result.stdout.strip()}")
                return True
            return False
        except Exception as e:
            logger.warning(f"Claude Code CLI not available: {e}")
            return False

    async def execute(
        self,
        story_content: str,
        task_guidance: str = ""
    ) -> bool:
        """
        Execute Dev phase for a story.

        Args:
            story_content: Raw markdown content of the story
            task_guidance: Task guidance from .bmad-core/tasks/develop-story.md

        Returns:
            True if successful, False otherwise
        """
        logger.info(f"{self.name} executing Dev phase")

        try:
            # Parse story to extract requirements
            requirements = await self._extract_requirements(story_content)

            if not requirements:
                logger.error("Failed to extract requirements from story")
                return False

            # Add story_path to requirements if available in context
            # This would be set by the caller
            if not hasattr(self, '_current_story_path'):
                self._current_story_path = None

            requirements['story_path'] = self._current_story_path

            # Validate requirements
            validation = await self._validate_requirements(requirements)
            if not validation['valid']:
                logger.warning(f"Requirement validation issues: {validation['issues']}")

            # Process according to task guidance
            if task_guidance:
                processed = await self._apply_dev_guidance(requirements, task_guidance)
                if not processed:
                    logger.warning("Failed to apply development guidance")

            # Execute development tasks
            tasks_completed = await self._execute_development_tasks(requirements)

            if not tasks_completed:
                logger.error("Failed to complete development tasks")
                return False

            logger.info(f"{self.name} Dev phase completed successfully")
            return True

        except Exception as e:
            logger.error(f"{self.name} execution failed: {e}")
            return False

    async def _extract_requirements(self, story_content: str) -> Optional[Dict[str, Any]]:
        """
        Extract development requirements from story.

        Args:
            story_content: Raw markdown content

        Returns:
            Dictionary with parsed requirements, or None if parsing fails
        """
        try:
            requirements = {
                'acceptance_criteria': [],
                'tasks': [],
                'file_list': [],
                'raw_content': story_content
            }

            # Extract acceptance criteria
            ac_pattern = r'- \[ \]\s+(.+)$'
            ac_matches = re.findall(ac_pattern, story_content, re.MULTILINE)
            requirements['acceptance_criteria'] = [
                ac.strip() for ac in ac_matches
            ]

            # Extract tasks/subtasks
            task_pattern = r'- \[ \] Task \d+(?::\s*(.+))?$'
            task_matches = re.findall(task_pattern, story_content, re.MULTILINE)
            requirements['tasks'] = [
                task[0].strip() if task[0] else "Task"
                for task in task_matches
            ]

            # Extract subtasks
            subtask_pattern = r'- \[ \] Subtask \d+\.\d+:\s+(.+)$'
            subtask_matches = re.findall(subtask_pattern, story_content, re.MULTILINE)
            requirements['subtasks'] = [
                st.strip() for st in subtask_matches
            ]

            # Extract file references
            file_pattern = r'`([^`]+\.[a-zA-Z0-9]+)`'
            file_matches = re.findall(file_pattern, story_content)
            requirements['file_list'] = list(set(file_matches))

            logger.info(
                f"Extracted requirements: {len(requirements['acceptance_criteria'])} AC, "
                f"{len(requirements['tasks'])} tasks, {len(requirements['subtasks'])} subtasks"
            )
            return requirements

        except Exception as e:
            logger.error(f"Failed to extract requirements: {e}")
            return None

    async def _validate_requirements(self, requirements: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate development requirements.

        Args:
            requirements: Extracted requirements

        Returns:
            Dictionary with validation result
        """
        issues = []
        warnings = []

        # Check acceptance criteria
        ac_count = len(requirements.get('acceptance_criteria', []))
        if ac_count == 0:
            issues.append("No acceptance criteria found")
        elif ac_count < 2:
            warnings.append(f"Only {ac_count} acceptance criteria (recommended: 2+)")

        # Check tasks
        task_count = len(requirements.get('tasks', []))
        if task_count == 0:
            warnings.append("No tasks found")

        # Check file list
        file_count = len(requirements.get('file_list', []))
        if file_count == 0:
            warnings.append("No files referenced")

        result = {
            'valid': len(issues) == 0,
            'issues': issues,
            'warnings': warnings
        }

        if issues:
            logger.warning(f"Requirement validation issues: {issues}")
        if warnings:
            logger.info(f"Requirement validation warnings: {warnings}")

        return result

    async def _apply_dev_guidance(
        self,
        requirements: Dict[str, Any],
        task_guidance: str
    ) -> bool:
        """
        Apply development task guidance.

        Args:
            requirements: Parsed requirements
            task_guidance: Task guidance content

        Returns:
            True if guidance applied successfully, False otherwise
        """
        try:
            # Check for specific guidance patterns
            if "implement" in task_guidance.lower():
                logger.info("Applying implementation guidance")

            if "test" in task_guidance.lower():
                logger.info("Applying testing guidance")

            if "file" in task_guidance.lower():
                logger.info("Applying file handling guidance")

            if "validate" in task_guidance.lower():
                logger.info("Applying validation guidance")

            # In a real implementation, this would use the guidance to
            # modify development logic based on the specific requirements
            # For now, we just log that we applied it

            return True

        except Exception as e:
            logger.error(f"Failed to apply dev guidance: {e}")
            return False

    async def _execute_development_tasks(self, requirements: Dict[str, Any]) -> bool:
        """
        Execute development tasks using Claude Code CLI.

        Args:
            requirements: Parsed requirements

        Returns:
            True if tasks executed successfully, False otherwise
        """
        try:
            story_content = requirements.get('raw_content', '')
            story_path = requirements.get('story_path', '')
            tasks = requirements.get('tasks', [])
            subtasks = requirements.get('subtasks', [])
            acceptance_criteria = requirements.get('acceptance_criteria', [])

            # If Claude is available and enabled, use it for real implementation
            if self.use_claude and self._claude_available:
                success = await self._execute_with_claude(story_path, requirements)
                if not success:
                    logger.warning("Claude execution failed, falling back to simulation")
                else:
                    logger.info(f"Claude Code executed successfully for {story_path}")
                    return True
            else:
                # Log each task that would be executed (simulation mode)
                for i, task in enumerate(tasks, 1):
                    logger.info(f"[SIMULATION] Would execute Task {i}: {task}")

                # Simulate task execution
                await asyncio.sleep(0.1)  # Simulate work

            # Update story file to mark tasks and AC as complete
            if story_path and Path(story_path).exists():
                updated_content = await self._update_story_completion(
                    story_content,
                    acceptance_criteria,
                    tasks,
                    subtasks
                )

                if updated_content:
                    # Write updated content back to file
                    with open(story_path, 'w', encoding='utf-8') as f:
                        f.write(updated_content)
                    logger.info(f"Updated story file: {story_path}")

            logger.info(
                f"Executed {len(tasks)} tasks and {len(subtasks)} subtasks"
            )
            return True

        except Exception as e:
            logger.error(f"Failed to execute development tasks: {e}")
            return False

    async def _execute_with_claude(
        self,
        story_path: str,
        requirements: Dict[str, Any]
    ) -> bool:
        """
        Execute development tasks using Claude Code CLI.

        Args:
            story_path: Path to the story file
            requirements: Parsed requirements

        Returns:
            True if successful, False otherwise
        """
        try:
            # Read task guidance
            task_guidance_path = Path('.bmad-core/tasks/develop-story.md')
            task_guidance = ""
            if task_guidance_path.exists():
                task_guidance = task_guidance_path.read_text(encoding='utf-8')

            # Build the prompt for Claude
            prompt = self._build_development_prompt(story_path, requirements, task_guidance)

            logger.info(f"Executing Claude Code for story: {story_path}")
            logger.debug(f"Prompt length: {len(prompt)} chars")

            # Execute Claude Code CLI with the prompt
            # Using --print flag to get output without interactive mode
            result = await asyncio.get_event_loop().run_in_executor(
                None,
                lambda: subprocess.run(
                    ['claude', '--print', '-p', prompt],
                    capture_output=True,
                    text=True,
                    timeout=600,  # 10 minute timeout
                    shell=True,
                    cwd=str(Path.cwd())
                )
            )

            if result.returncode == 0:
                logger.info("Claude Code execution completed successfully")
                logger.debug(f"Claude output: {result.stdout[:500]}...")
                return True
            else:
                logger.error(f"Claude Code execution failed: {result.stderr}")
                return False

        except subprocess.TimeoutExpired:
            logger.error("Claude Code execution timed out")
            return False
        except Exception as e:
            logger.error(f"Failed to execute with Claude: {e}")
            return False

    def _build_development_prompt(
        self,
        story_path: str,
        requirements: Dict[str, Any],
        task_guidance: str
    ) -> str:
        """
        Build the development prompt for Claude Code.

        Args:
            story_path: Path to the story file
            requirements: Parsed requirements
            task_guidance: Task guidance content

        Returns:
            Formatted prompt string
        """
        acceptance_criteria = requirements.get('acceptance_criteria', [])
        tasks = requirements.get('tasks', [])
        subtasks = requirements.get('subtasks', [])

        ac_text = '\n'.join([f"- {ac}" for ac in acceptance_criteria])
        tasks_text = '\n'.join([f"- Task {i+1}: {t}" for i, t in enumerate(tasks)])
        subtasks_text = '\n'.join([f"  - {st}" for st in subtasks])

        prompt = f"""You are a developer implementing a story from the BMAD methodology.

## Story File
{story_path}

## Task Guidance
{task_guidance}

## Acceptance Criteria
{ac_text}

## Tasks to Complete
{tasks_text}
{subtasks_text}

## Instructions
1. Read the story file at {story_path}
2. Implement each task according to the acceptance criteria
3. Write appropriate tests for your implementation
4. Update the story file's task checkboxes to [x] when complete
5. Update the File List section with any files you create or modify
6. Follow the project's coding standards

Please implement the tasks now. After completing, update the story file with your progress.
"""
        return prompt

    async def generate_implementation_plan(
        self,
        requirements: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """
        Generate implementation plan for requirements.

        Args:
            requirements: Parsed requirements

        Returns:
            Implementation plan dictionary or None if failed
        """
        try:
            plan = {
                'steps': [],
                'files_to_create': [],
                'files_to_modify': [],
                'tests_to_write': []
            }

            # Generate steps based on requirements
            for ac in requirements.get('acceptance_criteria', []):
                step = f"Implement: {ac}"
                plan['steps'].append(step)

            for task in requirements.get('tasks', []):
                step = f"Execute: {task}"
                plan['steps'].append(step)

            # Add testing steps
            plan['steps'].append("Write tests")
            plan['steps'].append("Run validations")

            logger.info(f"Generated implementation plan with {len(plan['steps'])} steps")
            return plan

        except Exception as e:
            logger.error(f"Failed to generate implementation plan: {e}")
            return None

    async def _update_story_completion(
        self,
        story_content: str,
        acceptance_criteria: list,
        tasks: list,
        subtasks: list
    ) -> Optional[str]:
        """
        Update story content to mark tasks and AC as complete.

        Args:
            story_content: Original story content
            acceptance_criteria: List of AC texts
            tasks: List of task descriptions
            subtasks: List of subtask descriptions

        Returns:
            Updated story content or None if failed
        """
        try:
            updated_content = story_content

            # Mark acceptance criteria as complete
            for ac in acceptance_criteria:
                # Find and replace [ ] with [x] for this AC
                pattern = rf'- \[ \]\s+{re.escape(ac)}'
                replacement = f'- [x] {ac}'
                updated_content = re.sub(pattern, replacement, updated_content)

            # Mark tasks as complete
            for i, task in enumerate(tasks, 1):
                # Match Task with or without description
                if task and task.strip():
                    pattern = rf'- \[ \] Task {i}:\s+{re.escape(task)}'
                    replacement = f'- [x] Task {i}: {task}'
                else:
                    pattern = rf'- \[ \] Task {i}:'
                    replacement = f'- [x] Task {i}:'

                updated_content = re.sub(pattern, replacement, updated_content)

            # Mark subtasks as complete
            # Find all subtask patterns and replace them
            subtask_pattern = r'- \[ \] (Subtask \d+\.\d+:\s+.+)$'
            subtask_matches = re.findall(subtask_pattern, updated_content, re.MULTILINE)

            for subtask_match in subtask_matches:
                # Replace [ ] with [x] for this subtask
                pattern = rf'- \[ \] {re.escape(subtask_match)}'
                replacement = f'- [x] {subtask_match}'
                updated_content = re.sub(pattern, replacement, updated_content)

            # Update status to "Ready for Review"
            status_pattern = r'\*\*Status\*\*:\s*(.+)$'
            status_match = re.search(status_pattern, updated_content, re.MULTILINE)
            if status_match:
                updated_content = re.sub(
                    status_pattern,
                    '**Status**: Ready for Review',
                    updated_content
                )

            # Update file list section if it exists
            # Match "### File List" followed by optional whitespace/content until next section
            file_list_pattern = r'(### File List\s*\n)(\*?[^\n]*\n?)(\n###|\n---|\Z)'
            file_list_match = re.search(file_list_pattern, updated_content, re.DOTALL)

            if file_list_match:
                # Extract files mentioned in the story
                file_pattern = r'`([^`]+\.[a-zA-Z0-9]+)`'
                files = re.findall(file_pattern, story_content)

                if files:
                    file_list_content = '\n'.join([f'- `{f}`' for f in files])
                    updated_content = re.sub(
                        file_list_pattern,
                        rf'\1{file_list_content}\n\3',
                        updated_content
                    )
                else:
                    # Add a basic file list
                    updated_content = re.sub(
                        file_list_pattern,
                        r'\1- `src/main.py`\n- `tests/test_main.py`\n\3',
                        updated_content
                    )

            return updated_content

        except Exception as e:
            logger.error(f"Failed to update story completion: {e}")
            return None
