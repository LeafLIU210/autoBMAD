"""
SDK Wrapper 单元测试

测试 SDK Wrapper 的核心功能：
1. SafeAsyncGenerator 异步生成器
2. SDKMessageTracker 消息跟踪
3. SafeClaudeSDK 主 SDK 包装器
4. 错误处理和恢复
5. 取消信号处理
6. 跨任务错误恢复
"""
import pytest
import asyncio
from unittest.mock import AsyncMock, MagicMock, patch, Mock
import sys
from pathlib import Path as PathLib

# 添加项目路径
sys.path.insert(0, str(PathLib(__file__).parent.parent.parent / "autoBMAD"))

from autoBMAD.epic_automation.sdk_wrapper import (
    SDKExecutionError,
    SafeAsyncGenerator,
    SDKMessageTracker,
    SafeClaudeSDK,
)


class TestSDKExecutionError:
    """SDKExecutionError 异常测试类"""

    def test_error_creation(self):
        """测试错误创建"""
        error = SDKExecutionError("Test error")
        assert str(error) == "Test error"
        assert isinstance(error, Exception)

    def test_error_with_cause(self):
        """测试带原因的錯誤"""
        original_error = ValueError("Original error")
        error = SDKExecutionError("Wrapped error", cause=original_error)
        assert str(error) == "Wrapped error"
        assert error.cause == original_error


class TestSafeAsyncGenerator:
    """SafeAsyncGenerator 测试类"""

    @pytest.mark.anyio
    async def test_init(self):
        """测试初始化"""
        generator = SafeAsyncGenerator()
        assert generator is not None

    @pytest.mark.anyio
    async def test_async_iteration(self):
        """测试异步迭代"""
        generator = SafeAsyncGenerator()
        items = [1, 2, 3]
        generator._items = items

        result = []
        async for item in generator:
            result.append(item)

        assert result == items

    @pytest.mark.anyio
    async def test_async_iteration_empty(self):
        """测试空迭代"""
        generator = SafeAsyncGenerator()
        generator._items = []

        result = []
        async for item in generator:
            result.append(item)

        assert result == []

    @pytest.mark.anyio
    async def test_async_iteration_with_exception(self):
        """测试迭代中的异常处理"""
        generator = SafeAsyncGenerator()

        # Mock __aiter__ and __anext__
        mock_anext = AsyncMock(side_effect=[1, 2, StopAsyncIteration()])
        generator.__anext__ = mock_anext

        result = []
        async for item in generator:
            result.append(item)

        assert len(result) == 2

    @pytest.mark.anyio
    async def test_aenter(self):
        """测试异步上下文管理器入口"""
        generator = SafeAsyncGenerator()
        async with generator as ctx:
            assert ctx is generator

    @pytest.mark.anyio
    async def test_aexit(self):
        """测试异步上下文管理器退出"""
        generator = SafeAsyncGenerator()
        async with generator:
            pass
        # 应该正常退出，没有异常


class TestSDKMessageTracker:
    """SDKMessageTracker 测试类"""

    @pytest.mark.anyio
    async def test_init(self):
        """测试初始化"""
        tracker = SDKMessageTracker()
        assert tracker is not None

    @pytest.mark.anyio
    async def test_track_message(self):
        """测试消息跟踪"""
        tracker = SDKMessageTracker()
        tracker.track_message("user", "Hello")

        # 验证消息被跟踪
        messages = tracker.get_messages()
        assert len(messages) == 1
        assert messages[0]["role"] == "user"
        assert messages[0]["content"] == "Hello"

    @pytest.mark.anyio
    async def test_track_multiple_messages(self):
        """测试多消息跟踪"""
        tracker = SDKMessageTracker()
        tracker.track_message("user", "Hello")
        tracker.track_message("assistant", "Hi there")
        tracker.track_message("user", "How are you?")

        messages = tracker.get_messages()
        assert len(messages) == 3
        assert messages[0]["role"] == "user"
        assert messages[1]["role"] == "assistant"
        assert messages[2]["role"] == "user"

    @pytest.mark.anyio
    async def test_clear_messages(self):
        """测试清空消息"""
        tracker = SDKMessageTracker()
        tracker.track_message("user", "Hello")
        tracker.track_message("assistant", "Hi")

        assert len(tracker.get_messages()) == 2

        tracker.clear_messages()

        assert len(tracker.get_messages()) == 0

    @pytest.mark.anyio
    async def test_get_last_message(self):
        """测试获取最后一条消息"""
        tracker = SDKMessageTracker()
        tracker.track_message("user", "First")
        tracker.track_message("user", "Second")
        tracker.track_message("user", "Third")

        last = tracker.get_last_message()
        assert last["content"] == "Third"

    @pytest.mark.anyio
    async def test_get_last_message_empty(self):
        """测试空消息获取最后一条"""
        tracker = SDKMessageTracker()

        last = tracker.get_last_message()
        assert last is None

    @pytest.mark.anyio
    async def test_get_messages_count(self):
        """测试获取消息数量"""
        tracker = SDKMessageTracker()
        assert tracker.get_messages_count() == 0

        tracker.track_message("user", "Hello")
        assert tracker.get_messages_count() == 1

        tracker.track_message("assistant", "Hi")
        assert tracker.get_messages_count() == 2


class TestSafeClaudeSDK:
    """SafeClaudeSDK 测试类"""

    @pytest.mark.anyio
    async def test_init_basic(self):
        """测试基本初始化"""
        sdk = SafeClaudeSDK()
        assert sdk is not None

    @pytest.mark.anyio
    async def test_init_with_config(self):
        """测试带配置的初始化"""
        config = {"timeout": 30}
        sdk = SafeClaudeSDK(config=config)
        assert sdk is not None

    @pytest.mark.anyio
    async def test_initialize(self):
        """测试初始化"""
        sdk = SafeClaudeSDK()
        # Mock 初始化过程
        with patch.object(sdk, '_initialize_sdk') as mock_init:
            await sdk.initialize()
            mock_init.assert_called_once()

    @pytest.mark.anyio
    async def test_execute_basic(self):
        """测试基本执行"""
        sdk = SafeClaudeSDK()

        # Mock Claude SDK
        mock_claude = MagicMock()
        mock_claude.messages.create = AsyncMock(return_value=MagicMock())

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            result = await sdk.execute(
                messages=[{"role": "user", "content": "Hello"}],
                use_claude=False
            )

            assert result is not None

    @pytest.mark.anyio
    async def test_execute_with_streaming(self):
        """测试流式执行"""
        sdk = SafeClaudeSDK()

        mock_response = MagicMock()
        mock_response._iter_lines = AsyncMock(return_value=iter([
            b'data: {"content": "Hello"}',
            b'data: {"content": " World"}',
            b'data: [DONE]'
        ]))

        mock_claude = MagicMock()
        mock_claude.messages.create = AsyncMock(return_value=mock_response)

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            result = await sdk.execute(
                messages=[{"role": "user", "content": "Hello"}],
                use_claude=False,
                stream=True
            )

            assert result is not None

    @pytest.mark.anyio
    async def test_execute_with_error(self):
        """测试执行错误处理"""
        sdk = SafeClaudeSDK()

        mock_claude = MagicMock()
        mock_claude.messages.create = AsyncMock(side_effect=Exception("API Error"))

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            with pytest.raises(SDKExecutionError):
                await sdk.execute(
                    messages=[{"role": "user", "content": "Hello"}],
                    use_claude=False
                )

    @pytest.mark.anyio
    async def test_execute_with_retry(self):
        """测试带重试的执行"""
        sdk = SafeClaudeSDK()

        mock_claude = MagicMock()
        # 第一次失败，第二次成功
        mock_claude.messages.create = AsyncMock(side_effect=[
            Exception("Temporary error"),
            MagicMock()
        ])

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            result = await sdk.execute(
                messages=[{"role": "user", "content": "Hello"}],
                use_claude=False,
                max_retries=3
            )

            assert result is not None
            assert mock_claude.messages.create.call_count == 2

    @pytest.mark.anyio
    async def test_execute_with_timeout(self):
        """测试超时处理"""
        sdk = SafeClaudeSDK()

        mock_claude = MagicMock()
        mock_claude.messages.create = AsyncMock(side_effect=asyncio.TimeoutError())

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            with pytest.raises(SDKExecutionError):
                await sdk.execute(
                    messages=[{"role": "user", "content": "Hello"}],
                    use_claude=False,
                    timeout=1
                )

    @pytest.mark.anyio
    async def test_execute_with_cancellation(self):
        """测试取消处理"""
        sdk = SafeClaudeSDK()

        mock_claude = MagicMock()
        mock_claude.messages.create = AsyncMock(side_effect=asyncio.CancelledError())

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            with pytest.raises(asyncio.CancelledError):
                await sdk.execute(
                    messages=[{"role": "user", "content": "Hello"}],
                    use_claude=False
                )

    @pytest.mark.anyio
    async def test_execute_with_max_tokens(self):
        """测试最大令牌数"""
        sdk = SafeClaudeSDK()

        mock_response = MagicMock()
        mock_claude = MagicMock()
        mock_claude.messages.create = AsyncMock(return_value=mock_response)

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            result = await sdk.execute(
                messages=[{"role": "user", "content": "Hello"}],
                use_claude=False,
                max_tokens=1000
            )

            assert result is not None
            # 验证调用时包含 max_tokens
            call_args = mock_claude.messages.create.call_args
            assert 'max_tokens' in call_args.kwargs or 'max_tokens' in call_args.args[1]

    @pytest.mark.anyio
    async def test_execute_with_system_prompt(self):
        """测试系统提示"""
        sdk = SafeClaudeSDK()

        mock_response = MagicMock()
        mock_claude = MagicMock()
        mock_claude.messages.create = AsyncMock(return_value=mock_response)

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            result = await sdk.execute(
                messages=[{"role": "user", "content": "Hello"}],
                use_claude=False,
                system="You are a helpful assistant"
            )

            assert result is not None

    @pytest.mark.anyio
    async def test_execute_with_temperature(self):
        """测试温度参数"""
        sdk = SafeClaudeSDK()

        mock_response = MagicMock()
        mock_claude = MagicMock()
        mock_claude.messages.create = AsyncMock(return_value=mock_response)

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            result = await sdk.execute(
                messages=[{"role": "user", "content": "Hello"}],
                use_claude=False,
                temperature=0.7
            )

            assert result is not None

    @pytest.mark.anyio
    async def test_close(self):
        """测试关闭"""
        sdk = SafeClaudeSDK()

        mock_claude = MagicMock()

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            await sdk.close()

            # 验证清理操作被调用
            assert mock_claude.close.call_count == 1

    @pytest.mark.anyio
    async def test_context_manager(self):
        """测试上下文管理器"""
        mock_claude = MagicMock()

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            async with SafeClaudeSDK() as sdk:
                assert sdk is not None

            # 验证离开上下文时关闭
            assert mock_claude.close.call_count == 1

    @pytest.mark.anyio
    async def test_message_tracking(self):
        """测试消息跟踪"""
        sdk = SafeClaudeSDK()

        mock_response = MagicMock()
        mock_claude = MagicMock()
        mock_claude.messages.create = AsyncMock(return_value=mock_response)

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            result = await sdk.execute(
                messages=[{"role": "user", "content": "Hello"}],
                use_claude=False,
                track_messages=True
            )

            assert result is not None
            # 验证消息被跟踪
            # (具体验证取决于实现细节)

    @pytest.mark.anyio
    async def test_batch_execute(self):
        """测试批量执行"""
        sdk = SafeClaudeSDK()

        mock_responses = [MagicMock(), MagicMock()]
        mock_claude = MagicMock()
        mock_claude.messages.create = AsyncMock(side_effect=mock_responses)

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            requests = [
                {"messages": [{"role": "user", "content": "Hello 1"}]},
                {"messages": [{"role": "user", "content": "Hello 2"}]}
            ]

            results = await sdk.batch_execute(
                requests=requests,
                use_claude=False
            )

            assert len(results) == 2
            assert all(r is not None for r in results)

    @pytest.mark.anyio
    async def test_execute_with_model(self):
        """测试指定模型"""
        sdk = SafeClaudeSDK()

        mock_response = MagicMock()
        mock_claude = MagicMock()
        mock_claude.messages.create = AsyncMock(return_value=mock_response)

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            result = await sdk.execute(
                messages=[{"role": "user", "content": "Hello"}],
                use_claude=False,
                model="claude-3-sonnet-20240229"
            )

            assert result is not None

    @pytest.mark.anyio
    async def test_execute_with_tool(self):
        """测试工具使用"""
        sdk = SafeClaudeSDK()

        mock_response = MagicMock()
        mock_claude = MagicMock()
        mock_claude.messages.create = AsyncMock(return_value=mock_response)

        with patch('autoBMAD.epic_automation.sdk_wrapper.ClaudeSDK', return_value=mock_claude):
            result = await sdk.execute(
                messages=[{"role": "user", "content": "Use a tool"}],
                use_claude=False,
                tools=[{"name": "test_tool", "description": "Test tool"}]
            )

            assert result is not None

    @pytest.mark.anyio
    async def test_is_initialized(self):
        """测试初始化状态检查"""
        sdk = SafeClaudeSDK()

        # 未初始化状态
        assert not sdk.is_initialized()

        # Mock 初始化
        with patch.object(sdk, '_client', MagicMock()):
            sdk._initialized = True
            assert sdk.is_initialized()

    @pytest.mark.anyio
    async def test_get_stats(self):
        """测试获取统计信息"""
        sdk = SafeClaudeSDK()

        stats = sdk.get_stats()
        assert isinstance(stats, dict)
        assert "request_count" in stats
        assert "error_count" in stats
        assert "total_tokens" in stats
