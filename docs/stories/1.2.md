### Status
**Done**

# Story 1.2: Basic Bubble Sort Implementation

**Status:** Ready for Development

## Epic Reference
- **Epic:** Core Algorithm Foundation
- **Epic ID:** 1
- **Story ID:** 1.2

## User Story

**As a user,**
I want a working bubble sort algorithm that can sort lists of numbers,
so that I can understand and use the fundamental sorting algorithm.

## Acceptance Criteria

1. **Core Function Implementation**
   - [ ] Implement `bubble_sort()` function in `src/bubble_sort/core/` directory
   - [ ] Function accepts a list/array as input parameter
   - [ ] Function returns a NEW sorted list (pure function - does not modify input)
   - [ ] Function signature: `def bubble_sort(numbers: List[int | float]) -> List[int | float]:`

2. **Edge Case Handling**
   - [ ] Empty list returns empty list
   - [ ] Single element list returns same list
   - [ ] Two element list sorts correctly
   - [ ] Lists with duplicate values handled correctly

3. **Error Handling**
   - [ ] Raises `TypeError` for None input
   - [ ] Raises `TypeError` for non-iterable input
   - [ ] Raises `ValueError` for non-comparable types (e.g., mixing strings and numbers)
   - [ ] All exceptions include descriptive error messages

4. **Documentation**
   - [ ] Comprehensive docstring following Google/NumPy style
   - [ ] Docstring includes:
     - Algorithm description
     - Time complexity analysis (O(nÂ²) worst/average case)
     - Space complexity (O(1))
     - Parameter descriptions
     - Return value description
     - Example usage
     - Edge case handling

5. **Type Hints**
   - [ ] All parameters have type hints
   - [ ] Return type is specified
   - [ ] Import `List` from `typing` module
   - [ ] Use Python 3.10+ union syntax OR typing.Union for compatibility

6. **Algorithm Correctness**
   - [ ] Implements standard bubble sort with nested loops
   - [ ] Outer loop runs n-1 times
   - [ ] Inner loop compares adjacent elements and swaps if needed
   - [ ] Includes early termination optimization (no swaps in a pass means sorted)
   - [ ] Correctly sorts in ascending order

## Tasks/Subtasks

### Task 1.2.1: Create Core Module Structure
- **Estimate:** 0.5 days
- **Priority:** High
- **Dependencies:** Story 1.1
- **Details:**
  - Create `src/bubble_sort/core/__init__.py`
  - Create `src/bubble_sort/core/sorting.py`
  - Verify module imports correctly

### Task 1.2.2: Implement Bubble Sort Algorithm
- **Estimate:** 1.5 days
- **Priority:** High
- **Dependencies:** Task 1.2.1
- **Details:**
  - Implement basic bubble sort logic
  - Add early termination optimization
  - Ensure pure function behavior (does not modify input)
  - Implement nested loop structure correctly

### Task 1.2.3: Add Type Hints
- **Estimate:** 0.25 days
- **Priority:** Medium
- **Dependencies:** Task 1.2.2
- **Details:**
  - Add type hints to function signature
  - Import necessary typing modules
  - Ensure type compatibility with Python 3.8+

### Task 1.2.4: Implement Error Handling
- **Estimate:** 0.5 days
- **Priority:** High
- **Dependencies:** Task 1.2.2
- **Details:**
  - Add None input validation
  - Add non-iterable input validation
  - Add non-comparable type validation
  - Write descriptive error messages

### Task 1.2.5: Write Comprehensive Documentation
- **Estimate:** 0.25 days
- **Priority:** Medium
- **Dependencies:** Task 1.2.3
- **Details:**
  - Write detailed docstring
  - Include algorithm explanation
  - Add complexity analysis
  - Include usage examples

## Dev Notes

### Algorithm Implementation Details
```python
# Pseudocode for bubble sort
def bubble_sort(numbers):
    n = len(numbers)
    # Traverse through all array elements
    for i in range(n):
        # Flag to optimize: if no swapping occurs, array is sorted
        swapped = False
        # Last i elements are already in place
        for j in range(0, n - i - 1):
            # Traverse the array from 0 to n-i-1
            # Swap if the element found is greater than the next element
            if numbers[j] > numbers[j + 1]:
                swapped = True
                numbers[j], numbers[j + 1] = numbers[j + 1], numbers[j]
        # If no two elements were swapped in inner loop, array is sorted
        if not swapped:
            break
    return numbers
```

### Key Implementation Points
- **Pure Function:** Create and return a new list, don't modify the input
- **Early Termination:** Track if any swaps occurred; if none, array is sorted
- **Loop Boundaries:** Outer loop n-1 times, inner loop n-i-1 times
- **Indexing:** Use 0-based indexing, compare j and j+1

### Error Handling Requirements
```python
# Validation examples
if numbers is None:
    raise TypeError("Input cannot be None")

try:
    # Attempt to iterate and compare
    iter(numbers)
except TypeError:
    raise TypeError("Input must be an iterable")

# For type checking during comparison
if not all(isinstance(x, (int, float)) for x in numbers):
    # Or handle mixed types more gracefully
    pass
```

### Testing Considerations
- Test with various list sizes (0, 1, 2, 10, 100+ elements)
- Test with different data types (integers, floats, negative numbers)
- Test with duplicate values
- Test with already sorted lists (best case)
- Test with reverse sorted lists (worst case)
- Test error cases (None, non-iterable, mixed types)

## Testing

### Unit Test Cases

#### Basic Functionality Tests
1. **Empty List Test**
   - [ ] Input: `[]`
   - [ ] Expected: `[]`
   - [ ] Verify: Returns empty list, doesn't raise error

2. **Single Element Test**
   - [ ] Input: `[42]`
   - [ ] Expected: `[42]`
   - [ ] Verify: Returns same element

3. **Two Elements Test**
   - [ ] Input: `[5, 2]`
   - [ ] Expected: `[2, 5]`
   - [ ] Verify: Elements swapped correctly

4. **Multiple Elements Test**
   - [ ] Input: `[64, 34, 25, 12, 22, 11, 90]`
   - [ ] Expected: `[11, 12, 22, 25, 34, 64, 90]`
   - [ ] Verify: All elements sorted correctly

#### Edge Case Tests
5. **Already Sorted Test**
   - [ ] Input: `[1, 2, 3, 4, 5]`
   - [ ] Expected: `[1, 2, 3, 4, 5]`
   - [ ] Verify: Early termination optimization works (single pass)

6. **Reverse Sorted Test**
   - [ ] Input: `[5, 4, 3, 2, 1]`
   - [ ] Expected: `[1, 2, 3, 4, 5]`
   - [ ] Verify: Full algorithm execution

7. **Duplicate Values Test**
   - [ ] Input: `[5, 2, 5, 2, 5]`
   - [ ] Expected: `[2, 2, 5, 5, 5]`
   - [ ] Verify: Duplicates handled correctly

8. **Negative Numbers Test**
   - [ ] Input: `[0, -1, 5, -3, 2]`
   - [ ] Expected: `[-3, -1, 0, 2, 5]`
   - [ ] Verify: Negative numbers sorted correctly

9. **Float Numbers Test**
   - [ ] Input: `[3.14, 2.71, 1.41, 1.73]`
   - [ ] Expected: `[1.41, 1.73, 2.71, 3.14]`
   - [ ] Verify: Floating point numbers sorted correctly

#### Error Handling Tests
10. **None Input Test**
    - [ ] Input: `None`
    - [ ] Expected: `TypeError` raised
    - [ ] Verify: Error message is descriptive

11. **Non-Iterable Test**
    - [ ] Input: `42`
    - [ ] Expected: `TypeError` raised
    - [ ] Verify: Error message is descriptive

12. **Mixed Types Test**
    - [ ] Input: `[1, "two", 3]`
    - [ ] Expected: `ValueError` or `TypeError` raised
    - [ ] Verify: Incompatible types handled

#### Purity Tests
13. **Input Preservation Test**
    - [ ] Input: `[5, 2, 8, 1]` (stored in variable `original`)
    - [ ] Expected: `[5, 2, 8, 1]` remains unchanged in `original`
    - [ ] Verify: Function does not modify input list

### Integration Tests
- [ ] Function can be imported from package
- [ ] Function works with CLI (when implemented in Story 1.4)
- [ ] Function works with test suite

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All tasks completed and reviewed
- [ ] Function passes all unit tests
- [ ] Error handling works correctly for all edge cases
- [ ] Function is a pure function (does not modify input)
- [ ] Comprehensive docstring with all required sections
- [ ] Type hints implemented correctly
- [ ] Algorithm correctness verified (tested against multiple scenarios)
- [ ] Code follows PEP 8 style guidelines
- [ ] No mypy type checking errors
- [ ] All tests pass with 100% success rate
- [ ] Code coverage >95% for this module

## Notes

- This is a pure educational implementation; performance is not critical
- Focus on clarity and correctness over optimization
- The algorithm should be easy to understand and trace through
- Consider adding comments explaining each step for educational value
- The early termination optimization is important for demonstrating algorithm understanding
