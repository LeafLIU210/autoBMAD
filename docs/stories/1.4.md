### Status
**Done**

# Story 1.4: Command-Line Interface

**Status:** Ready for Development

## Epic Reference
- **Epic:** Core Algorithm Foundation
- **Epic ID:** 1
- **Story ID:** 1.4

## User Story

**As a user,**
I want a command-line interface to test the bubble sort algorithm,
so that I can easily demonstrate and experiment with the implementation.

## Acceptance Criteria

1. **CLI Implementation**
   - [ ] Create CLI module at `src/bubble_sort/cli/main.py`
   - [ ] Implement `main()` function as entry point
   - [ ] Use `argparse` or `click` for command-line argument parsing
   - [ ] Create `__init__.py` for CLI module

2. **Input Methods**
   - [ ] Accept arrays as command-line arguments
     - Format: `bubble-sort 5 2 8 1 9`
     - Parse space-separated numbers
   - [ ] Support reading from files
     - Format: One number per line or comma-separated
     - Use `--file` or `-f` flag
   - [ ] Support standard input (pipe input)
     - Format: `echo "5 2 8" | bubble-sort`
     - Accept space-separated or comma-separated values

3. **Output Options**
   - [ ] Default: Print sorted array as space-separated values
   - [ ] Verbose mode (`--verbose` or `-v`): Show input and detailed process
   - [ ] JSON mode (`--json` or `-j`): Output in JSON format
   - [ ] Step-by-step mode (`--steps` or `-s`): Show each pass through the array

4. **Command-Line Options**
   - [ ] `--help` / `-h`: Display usage information
   - [ ] `--version` / `-V`: Display version information
   - [ ] `--file` / `-f`: Read input from file
   - [ ] `--verbose` / `-v`: Enable verbose output
   - [ ] `--json` / `-j`: JSON output format
   - [ ] `--steps` / `-s`: Show sorting steps
   - [ ] `--quiet` / `-q`: Minimal output (sorted array only)

5. **Error Handling**
   - [ ] Gracefully handle invalid number inputs
   - [ ] Display helpful error messages for missing files
   - [ ] Validate file format and content
   - [ ] Handle empty input gracefully
   - [ ] Exit with appropriate status codes (0=success, 1=error)

6. **Entry Point Configuration**
   - [ ] Configure console script in `pyproject.toml`
   - [ ] Entry point name: `bubble-sort`
   - [ ] Can be installed and run from anywhere
   - [ ] Works in virtual environments

7. **Documentation**
   - [ ] Include `--help` documentation with examples
   - [ ] README.md updated with CLI usage examples
   - [ ] Include examples for all input methods
   - [ ] Include examples for all output formats

## Tasks/Subtasks

### Task 1.4.1: Create CLI Module Structure
- **Estimate:** 0.5 days
- **Priority:** High
- **Dependencies:** Story 1.2
- **Details:**
  - Create CLI directory and module files
  - Setup basic module structure
  - Create main() function stub

### Task 1.4.2: Implement Argument Parsing
- **Estimate:** 0.5 days
- **Priority:** High
- **Dependencies:** Task 1.4.1
- **Details:**
  - Setup argparse configuration
  - Define all command-line arguments
  - Add help text and descriptions
  - Test argument parsing

### Task 1.4.3: Implement Input Handling
- **Estimate:** 0.5 days
- **Priority:** High
- **Dependencies:** Task 1.4.2
- **Details:**
  - Parse command-line arguments
  - Implement file reading
  - Implement standard input reading
  - Add input validation

### Task 1.4.4: Implement Sorting Logic Integration
- **Estimate:** 0.25 days
- **Priority:** High
- **Dependencies:** Task 1.4.3
- **Details:**
  - Import and use bubble_sort function
  - Handle various input types
  - Ensure pure function behavior

### Task 1.4.5: Implement Output Formatting
- **Estimate:** 0.5 days
- **Priority:** Medium
- **Dependencies:** Task 1.4.4
- **Details:**
  - Default output format
  - Verbose mode output
  - JSON format output
  - Step-by-step mode output

### Task 1.4.6: Configure Entry Point
- **Estimate:** 0.25 days
- **Priority:** Medium
- **Dependencies:** Task 1.4.5
- **Details:**
  - Configure console script in pyproject.toml
  - Test installation and execution
  - Verify command works from anywhere

### Task 1.4.7: Add Documentation and Examples
- **Estimate:** 0.5 days
- **Priority:** Medium
- **Dependencies:** Task 1.4.6
- **Details:**
  - Update README.md with CLI examples
  - Add inline help documentation
  - Test all documented examples

## Dev Notes

### CLI Implementation Pattern
```python
# src/bubble_sort/cli/main.py
import argparse
import json
import sys
from typing import List, Optional
from bubble_sort.core.sorting import bubble_sort


def parse_arguments(args: Optional[List[str]] = None) -> argparse.Namespace:
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(
        description="Sort a list of numbers using bubble sort algorithm",
        epilog="Examples:\n"
               "  %(prog)s 5 2 8 1 9\n"
               "  %(prog)s --file numbers.txt\n"
               "  echo '5,2,8,1,9' | %(prog)s",
    )
    parser.add_argument("numbers", nargs="*", type=float,
                       help="Numbers to sort (space-separated)")
    parser.add_argument("-f", "--file", type=str,
                       help="Read numbers from file")
    parser.add_argument("-v", "--verbose", action="store_true",
                       help="Verbose output")
    parser.add_argument("-j", "--json", action="store_true",
                       help="Output in JSON format")
    parser.add_argument("-s", "--steps", action="store_true",
                       help="Show sorting steps")
    parser.add_argument("-q", "--quiet", action="store_true",
                       help="Minimal output")
    parser.add_argument("--version", action="version", version="%(prog)s 1.0.0")

    return parser.parse_args(args)


def read_from_file(filename: str) -> List[float]:
    """Read numbers from a file."""
    with open(filename, 'r') as f:
        content = f.read().strip()
        # Support comma-separated or whitespace-separated
        if ',' in content:
            return [float(x.strip()) for x in content.split(',')]
        else:
            return [float(x.strip()) for x in content.split()]


def read_from_stdin() -> List[float]:
    """Read numbers from standard input."""
    content = sys.stdin.read().strip()
    if ',' in content:
        return [float(x.strip()) for x in content.split(',')]
    else:
        return [float(x.strip()) for x in content.split()]


def format_output(numbers: List[float], verbose: bool = False,
                  json_output: bool = False, steps: bool = False) -> str:
    """Format the output based on options."""
    if json_output:
        return json.dumps({"sorted": numbers})
    elif steps:
        # Implementation would track each step
        return f"Sorted array: {numbers}"
    elif verbose:
        return f"Input processed. Sorted result: {numbers}"
    else:
        return " ".join(map(str, numbers))


def main(args: Optional[List[str]] = None) -> int:
    """Main entry point for the CLI."""
    try:
        parsed_args = parse_arguments(args)

        # Determine input source
        if parsed_args.file:
            numbers = read_from_file(parsed_args.file)
        elif parsed_args.numbers:
            numbers = parsed_args.numbers
        elif not sys.stdin.isatty():
            numbers = read_from_stdin()
        else:
            print("Error: No input provided. Use --help for usage information.")
            return 1

        # Validate input
        if not numbers:
            print("Error: No numbers to sort.")
            return 1

        # Sort the numbers
        sorted_numbers = bubble_sort(numbers)

        # Format and print output
        output = format_output(
            sorted_numbers,
            verbose=parsed_args.verbose,
            json_output=parsed_args.json,
            steps=parsed_args.steps
        )
        print(output)

        return 0

    except FileNotFoundError:
        print(f"Error: File not found.")
        return 1
    except ValueError as e:
        print(f"Error: Invalid input - {e}")
        return 1
    except Exception as e:
        print(f"Error: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
```

### Entry Point Configuration
Add to `pyproject.toml`:
```toml
[tool.poetry.scripts]
bubble-sort = "bubble_sort.cli.main:main"

# OR if using setuptools:

[project.scripts]
bubble-sort = "bubble_sort.cli.main:main"
```

### Input File Formats
1. **Whitespace-separated:**
   ```
   5 2 8 1 9
   ```

2. **Comma-separated:**
   ```
   5,2,8,1,9
   ```

3. **One per line:**
   ```
   5
   2
   8
   1
   9
   ```

### Output Examples

#### Default Output
```bash
$ bubble-sort 5 2 8 1 9
1 2 5 8 9
```

#### Verbose Output
```bash
$ bubble-sort -v 5 2 8 1 9
Input processed. Sorted result: [1, 2, 5, 8, 9]
```

#### JSON Output
```bash
$ bubble-sort -j 5 2 8 1 9
{"sorted": [1, 2, 5, 8, 9]}
```

#### File Input
```bash
$ bubble-sort --file numbers.txt
# Output depends on file contents
```

#### Pipe Input
```bash
$ echo "5,2,8,1,9" | bubble-sort
1 2 5 8 9
```

## Testing

### CLI Test Cases

#### 1. Basic Functionality Tests
- [ ] **Command-line arguments**
  - [ ] Input: `bubble-sort 5 2 8 1 9`
  - [ ] Expected: `1 2 5 8 9`

- [ ] **File input**
  - [ ] Input: `bubble-sort --file test.txt`
  - [ ] Expected: Sorted output based on file contents

- [ ] **Standard input**
  - [ ] Input: `echo "5 2 8" | bubble-sort`
  - [ ] Expected: `2 5 8`

#### 2. Output Format Tests
- [ ] **Default format**
  - [ ] Space-separated sorted numbers

- [ ] **Verbose mode**
  - [ ] Descriptive message with sorted result

- [ ] **JSON mode**
  - [ ] Valid JSON output with sorted array

- [ ] **Quiet mode**
  - [ ] Minimal output (same as default)

#### 3. Edge Case Tests
- [ ] **Empty input**
  - [ ] Input: `bubble-sort` (no arguments)
  - [ ] Expected: Error message or empty output

- [ ] **Single element**
  - [ ] Input: `bubble-sort 42`
  - [ ] Expected: `42`

- [ ] **Large dataset**
  - [ ] Input: `bubble-sort` with 100+ numbers
  - [ ] Expected: Correctly sorted output

#### 4. Error Handling Tests
- [ ] **Invalid file**
  - [ ] Input: `bubble-sort --file nonexistent.txt`
  - [ ] Expected: File not found error

- [ ] **Invalid number**
  - [ ] Input: `bubble-sort 5 abc 9`
  - [ ] Expected: Value error with descriptive message

- [ ] **Missing input**
  - [ ] Input: `bubble-sort` (with no stdin)
  - [ ] Expected: Usage information or error

#### 5. Integration Tests
- [ ] **CLI integrates with core module**
  - [ ] Verifies bubble_sort function is called correctly

- [ ] **Entry point works**
  - [ ] After installation, `bubble-sort` command is available

### Test Implementation
```python
# tests/test_cli/test_main.py
import pytest
from bubble_sort.cli.main import main, parse_arguments

class TestParseArguments:
    def test_parse_numbers(self):
        args = parse_arguments(["5", "2", "8"])
        assert args.numbers == [5.0, 2.0, 8.0]

    def test_parse_file_flag(self):
        args = parse_arguments(["--file", "test.txt"])
        assert args.file == "test.txt"

    def test_parse_verbose_flag(self):
        args = parse_arguments(["--verbose"])
        assert args.verbose is True

class TestMain:
    def test_main_with_numbers(self, capsys):
        result = main(["5", "2", "8", "1"])
        assert result == 0
        captured = capsys.readouterr()
        assert "1 2 5 8" in captured.out

    def test_main_with_invalid_file(self):
        result = main(["--file", "nonexistent.txt"])
        assert result == 1
```

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All tasks completed and reviewed
- [ ] CLI works with all input methods (args, file, stdin)
- [ ] All output formats implemented and tested
- [ ] All command-line options functional
- [ ] Error handling works correctly
- [ ] Entry point configured and tested
- [ ] All tests pass with 100% success rate
- [ ] CLI integrates correctly with bubble_sort function
- [ ] Documentation complete and accurate
- [ ] Examples in README.md tested and working
- [ ] Command can be installed and run from anywhere
- [ ] Works across all supported Python versions
- [ ] CI/CD pipeline tests CLI functionality

## Notes

- Focus on usability and clear error messages
- Support multiple input formats for flexibility
- Ensure CLI works well with Unix piping
- Consider adding interactive mode (optional enhancement)
- Test thoroughly with various input sizes
- Ensure consistent behavior across platforms (Windows, Linux, macOS)
